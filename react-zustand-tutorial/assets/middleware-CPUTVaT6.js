const E={BASE_URL:"./",DEV:!1,MODE:"production",PROD:!0,SSR:!1},_=new Map,b=l=>{const u=_.get(l);return u?Object.fromEntries(Object.entries(u.stores).map(([n,r])=>[n,r.getState()])):{}},C=(l,u,n)=>{if(l===void 0)return{type:"untracked",connection:u.connect(n)};const r=_.get(n.name);if(r)return{type:"tracked",store:l,...r};const e={connection:u.connect(n),stores:{}};return _.set(n.name,e),{type:"tracked",store:l,...e}},R=(l,u)=>{if(u===void 0)return;const n=_.get(l);n&&(delete n.stores[u],Object.keys(n.stores).length===0&&_.delete(l))},N=l=>{var u,n;if(!l)return;const r=l.split(`
`),e=r.findIndex(S=>S.includes("api.setState"));if(e<0)return;const s=((u=r[e+1])==null?void 0:u.trim())||"";return(n=/.+ (.+) .+/.exec(s))==null?void 0:n[1]},k=(l,u={})=>(n,r,e)=>{const{enabled:s,anonymousActionType:S,store:i,...f}=u;let m;try{m=(s??(E?"production":void 0)!=="production")&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!m)return l(n,r,e);const{connection:o,...h}=C(i,m,f);let y=!0;e.setState=(t,v,a)=>{const c=n(t,v);if(!y)return c;const p=a===void 0?{type:S||N(new Error().stack)||"anonymous"}:typeof a=="string"?{type:a}:a;return i===void 0?(o==null||o.send(p,r()),c):(o==null||o.send({...p,type:`${i}/${p.type}`},{...b(f.name),[i]:e.getState()}),c)},e.devtools={cleanup:()=>{o&&typeof o.unsubscribe=="function"&&o.unsubscribe(),R(f.name,i)}};const d=(...t)=>{const v=y;y=!1,n(...t),y=v},g=l(e.setState,r,e);if(h.type==="untracked"?o==null||o.init(g):(h.stores[h.store]=e,o==null||o.init(Object.fromEntries(Object.entries(h.stores).map(([t,v])=>[t,t===h.store?g:v.getState()])))),e.dispatchFromDevtools&&typeof e.dispatch=="function"){let t=!1;const v=e.dispatch;e.dispatch=(...a)=>{(E?"production":void 0)!=="production"&&a[0].type==="__setState"&&!t&&(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),t=!0),v(...a)}}return o.subscribe(t=>{var v;switch(t.type){case"ACTION":if(typeof t.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return O(t.payload,a=>{if(a.type==="__setState"){if(i===void 0){d(a.state);return}Object.keys(a.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format.
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const c=a.state[i];if(c==null)return;JSON.stringify(e.getState())!==JSON.stringify(c)&&d(c);return}e.dispatchFromDevtools&&typeof e.dispatch=="function"&&e.dispatch(a)});case"DISPATCH":switch(t.payload.type){case"RESET":return d(g),i===void 0?o==null?void 0:o.init(e.getState()):o==null?void 0:o.init(b(f.name));case"COMMIT":if(i===void 0){o==null||o.init(e.getState());return}return o==null?void 0:o.init(b(f.name));case"ROLLBACK":return O(t.state,a=>{if(i===void 0){d(a),o==null||o.init(e.getState());return}d(a[i]),o==null||o.init(b(f.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return O(t.state,a=>{if(i===void 0){d(a);return}JSON.stringify(e.getState())!==JSON.stringify(a[i])&&d(a[i])});case"IMPORT_STATE":{const{nextLiftedState:a}=t.payload,c=(v=a.computedStates.slice(-1)[0])==null?void 0:v.state;if(!c)return;d(i===void 0?c:c[i]),o==null||o.send(null,a);return}case"PAUSE_RECORDING":return y=!y}return}}),g},F=k,O=(l,u)=>{let n;try{n=JSON.parse(l)}catch(r){console.error("[zustand devtools middleware] Could not parse the received json",r)}n!==void 0&&u(n)},D=l=>(u,n,r)=>{const e=r.subscribe;return r.subscribe=(S,i,f)=>{let m=S;if(i){const o=(f==null?void 0:f.equalityFn)||Object.is;let h=S(r.getState());m=y=>{const d=S(y);if(!o(h,d)){const g=h;i(h=d,g)}},f!=null&&f.fireImmediately&&i(h,h)}return e(m)},l(u,n,r)},x=D;function J(l,u){let n;try{n=l()}catch{return}return{getItem:e=>{var s;const S=f=>f===null?null:JSON.parse(f,void 0),i=(s=n.getItem(e))!=null?s:null;return i instanceof Promise?i.then(S):S(i)},setItem:(e,s)=>n.setItem(e,JSON.stringify(s,void 0)),removeItem:e=>n.removeItem(e)}}const T=l=>u=>{try{const n=l(u);return n instanceof Promise?n:{then(r){return T(r)(n)},catch(r){return this}}}catch(n){return{then(r){return this},catch(r){return T(r)(n)}}}},j=(l,u)=>(n,r,e)=>{let s={storage:J(()=>localStorage),partialize:t=>t,version:0,merge:(t,v)=>({...v,...t}),...u},S=!1;const i=new Set,f=new Set;let m=s.storage;if(!m)return l((...t)=>{console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),n(...t)},r,e);const o=()=>{const t=s.partialize({...r()});return m.setItem(s.name,{state:t,version:s.version})},h=e.setState;e.setState=(t,v)=>(h(t,v),o());const y=l((...t)=>(n(...t),o()),r,e);e.getInitialState=()=>y;let d;const g=()=>{var t,v;if(!m)return;S=!1,i.forEach(c=>{var p;return c((p=r())!=null?p:y)});const a=((v=s.onRehydrateStorage)==null?void 0:v.call(s,(t=r())!=null?t:y))||void 0;return T(m.getItem.bind(m))(s.name).then(c=>{if(c)if(typeof c.version=="number"&&c.version!==s.version){if(s.migrate){const p=s.migrate(c.state,c.version);return p instanceof Promise?p.then(I=>[!0,I]):[!0,p]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,c.state];return[!1,void 0]}).then(c=>{var p;const[I,w]=c;if(d=s.merge(w,(p=r())!=null?p:y),n(d,!0),I)return o()}).then(()=>{a==null||a(d,void 0),d=r(),S=!0,f.forEach(c=>c(d))}).catch(c=>{a==null||a(void 0,c)})};return e.persist={setOptions:t=>{s={...s,...t},t.storage&&(m=t.storage)},clearStorage:()=>{m==null||m.removeItem(s.name)},getOptions:()=>s,rehydrate:()=>g(),hasHydrated:()=>S,onHydrate:t=>(i.add(t),()=>{i.delete(t)}),onFinishHydration:t=>(f.add(t),()=>{f.delete(t)})},s.skipHydration||g(),d||y},A=j;export{J as c,F as d,A as p,x as s};
