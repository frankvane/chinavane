var q=Object.defineProperty;var R=(i,s,t)=>s in i?q(i,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[s]=t;var m=(i,s,t)=>R(i,typeof s!="symbol"?s+"":s,t);import{j as e,r as l}from"./index-Bi_r7QuH.js";import{C}from"./ComponentTemplate-C5EWLtXX.js";class y{constructor(s,t){m(this,"capacity");m(this,"tokens");m(this,"refillRate");m(this,"lastRefill");this.capacity=s,this.tokens=s,this.refillRate=t,this.lastRefill=Date.now()}consume(s=1){return this.refill(),this.tokens>=s?(this.tokens-=s,!0):!1}refill(){const s=Date.now(),o=(s-this.lastRefill)/1e3*this.refillRate;this.tokens=Math.min(this.capacity,this.tokens+o),this.lastRefill=s}getTokens(){return this.refill(),Math.floor(this.tokens)}getCapacity(){return this.capacity}reset(){this.tokens=this.capacity,this.lastRefill=Date.now()}}class v{constructor(s,t){m(this,"windowSize");m(this,"maxRequests");m(this,"requests");this.windowSize=s*1e3,this.maxRequests=t,this.requests=[]}isAllowed(){const s=Date.now();return this.requests=this.requests.filter(t=>s-t<this.windowSize),this.requests.length<this.maxRequests?(this.requests.push(s),!0):!1}getCurrentCount(){const s=Date.now();return this.requests=this.requests.filter(t=>s-t<this.windowSize),this.requests.length}getMaxRequests(){return this.maxRequests}reset(){this.requests=[]}}class k{constructor(s,t){m(this,"windowSize");m(this,"maxRequests");m(this,"currentWindow");m(this,"requestCount");this.windowSize=s*1e3,this.maxRequests=t,this.currentWindow=Math.floor(Date.now()/this.windowSize),this.requestCount=0}isAllowed(){const s=Date.now(),t=Math.floor(s/this.windowSize);return t>this.currentWindow&&(this.currentWindow=t,this.requestCount=0),this.requestCount<this.maxRequests?(this.requestCount++,!0):!1}getCurrentCount(){const s=Date.now();return Math.floor(s/this.windowSize)>this.currentWindow?0:this.requestCount}getMaxRequests(){return this.maxRequests}reset(){this.currentWindow=Math.floor(Date.now()/this.windowSize),this.requestCount=0}}class N{constructor(){m(this,"limiters",new Map)}createTokenBucket(s,t,o){const c=new y(t,o);return this.limiters.set(s,c),c}createSlidingWindow(s,t,o){const c=new v(t,o);return this.limiters.set(s,c),c}createFixedWindow(s,t,o){const c=new k(t,o);return this.limiters.set(s,c),c}checkRequest(s){const t=this.limiters.get(s);return t?t instanceof y?t.consume():t instanceof v||t instanceof k?t.isAllowed():!0:!0}getLimiterStatus(s){const t=this.limiters.get(s);return t?t instanceof y?{type:"TokenBucket",tokens:t.getTokens(),capacity:t.getCapacity()}:t instanceof v?{type:"SlidingWindow",currentCount:t.getCurrentCount(),maxRequests:t.getMaxRequests()}:t instanceof k?{type:"FixedWindow",currentCount:t.getCurrentCount(),maxRequests:t.getMaxRequests()}:null:null}resetLimiter(s){const t=this.limiters.get(s);t&&"reset"in t&&t.reset()}removeLimiter(s){this.limiters.delete(s)}}const S={title:"滑动窗口算法实现",language:"typescript",code:`// 滑动窗口算法实现
class SlidingWindow {
  private windowSize: number;
  private maxRequests: number;
  private requests: number[];

  constructor(windowSize: number, maxRequests: number) {
    this.windowSize = windowSize * 1000; // 转换为毫秒
    this.maxRequests = maxRequests;
    this.requests = [];
  }

  // 检查是否允许请求
  isAllowed(): boolean {
    const now = Date.now();

    // 移除过期的请求记录
    this.requests = this.requests.filter(
      timestamp => now - timestamp < this.windowSize
    );

    // 检查是否超过最大请求数
    if (this.requests.length < this.maxRequests) {
      this.requests.push(now);
      return true;
    }

    return false;
  }

  // 获取当前窗口内的请求数
  getCurrentCount(): number {
    const now = Date.now();
    this.requests = this.requests.filter(
      timestamp => now - timestamp < this.windowSize
    );
    return this.requests.length;
  }
}`,highlights:[19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39]},L={title:"限流算法对比实现",language:"typescript",code:`// 限流算法管理器
class RateLimitManager {
  // 实现代码
}`,highlights:[1,2,3]},T=()=>{const[i]=l.useState(()=>new N),[s,t]=l.useState(10),[o,c]=l.useState(2),[d,j]=l.useState(null),[h,b]=l.useState([]),p=l.useRef(null),x="token-bucket-demo";l.useEffect(()=>{i.createTokenBucket(x,s,o),u()},[s,o]),l.useEffect(()=>(p.current=setInterval(u,100),()=>{p.current&&clearInterval(p.current)}),[]);const u=l.useCallback(()=>{const n=i.getLimiterStatus(x);j(n)},[i]),r=l.useCallback(()=>{const n=i.checkRequest(x),g={time:new Date().toLocaleTimeString(),allowed:n};b(f=>[g,...f.slice(0,9)]),u()},[i,u]),a=l.useCallback(()=>{i.resetLimiter(x),b([]),u()},[i,u]),w=l.useCallback(()=>{for(let n=0;n<5;n++)setTimeout(()=>r(),n*100)},[r]);return e.jsx("div",{className:"space-y-4",children:e.jsxs("div",{className:"bg-white p-6 rounded-lg border",children:[e.jsx("h3",{className:"text-lg font-semibold mb-4",children:"令牌桶算法演示"}),e.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-2 gap-4 mb-4",children:[e.jsxs("div",{children:[e.jsx("label",{className:"block text-sm font-medium text-gray-700 mb-2",children:"桶容量 (最大令牌数)"}),e.jsx("input",{type:"number",value:s,onChange:n=>t(parseInt(n.target.value)||10),min:"1",max:"100",className:"w-full p-2 border border-gray-300 rounded-md"})]}),e.jsxs("div",{children:[e.jsx("label",{className:"block text-sm font-medium text-gray-700 mb-2",children:"补充速率 (令牌/秒)"}),e.jsx("input",{type:"number",value:o,onChange:n=>c(parseFloat(n.target.value)||2),min:"0.1",max:"10",step:"0.1",className:"w-full p-2 border border-gray-300 rounded-md"})]})]}),d&&e.jsxs("div",{className:"mb-4 p-4 bg-blue-50 rounded-lg",children:[e.jsx("h4",{className:"font-medium text-blue-900 mb-2",children:"令牌桶状态"}),e.jsx("div",{className:"flex items-center space-x-4",children:e.jsxs("div",{className:"flex-1",children:[e.jsxs("div",{className:"flex justify-between text-sm text-blue-700 mb-1",children:[e.jsx("span",{children:"当前令牌数"}),e.jsxs("span",{children:[d.tokens," / ",d.capacity]})]}),e.jsx("div",{className:"w-full bg-blue-200 rounded-full h-2",children:e.jsx("div",{className:"bg-blue-600 h-2 rounded-full transition-all duration-300",style:{width:(d.tokens||0)/(d.capacity||1)*100+"%"}})})]})})]}),e.jsxs("div",{className:"flex space-x-4 mb-4",children:[e.jsx("button",{onClick:r,className:"px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700",children:"发送请求"}),e.jsx("button",{onClick:w,className:"px-4 py-2 bg-orange-600 text-white rounded-md hover:bg-orange-700",children:"突发请求 (5个)"}),e.jsx("button",{onClick:a,className:"px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700",children:"重置"})]}),h.length>0&&e.jsxs("div",{children:[e.jsx("h4",{className:"font-medium text-gray-900 mb-2",children:"请求日志"}),e.jsx("div",{className:"space-y-1 max-h-40 overflow-y-auto",children:h.map((n,g)=>e.jsxs("div",{className:`flex justify-between items-center p-2 rounded text-sm ${n.allowed?"bg-green-100 text-green-800":"bg-red-100 text-red-800"}`,children:[e.jsx("span",{children:n.time}),e.jsx("span",{children:n.allowed?"✅ 允许":"❌ 拒绝"})]},g))})]})]})})},W=()=>{const[i]=l.useState(()=>new N),[s,t]=l.useState(10),[o,c]=l.useState(5),[d,j]=l.useState(null),[h,b]=l.useState([]),p=l.useRef(null),x="sliding-window-demo";l.useEffect(()=>{i.createSlidingWindow(x,s,o),u()},[s,o]),l.useEffect(()=>(p.current=setInterval(u,100),()=>{p.current&&clearInterval(p.current)}),[]);const u=l.useCallback(()=>{const n=i.getLimiterStatus(x);j(n)},[i]),r=l.useCallback(()=>{const n=i.checkRequest(x),g={time:new Date().toLocaleTimeString(),allowed:n};b(f=>[g,...f.slice(0,9)]),u()},[i,u]),a=l.useCallback(()=>{i.resetLimiter(x),b([]),u()},[i,u]),w=l.useCallback(()=>{const n=setInterval(()=>{r()},1e3);setTimeout(()=>{clearInterval(n)},8e3)},[r]);return e.jsx("div",{className:"space-y-4",children:e.jsxs("div",{className:"bg-white p-6 rounded-lg border",children:[e.jsx("h3",{className:"text-lg font-semibold mb-4",children:"滑动窗口算法演示"}),e.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-2 gap-4 mb-4",children:[e.jsxs("div",{children:[e.jsx("label",{className:"block text-sm font-medium text-gray-700 mb-2",children:"窗口大小 (秒)"}),e.jsx("input",{type:"number",value:s,onChange:n=>t(parseInt(n.target.value)||10),min:"1",max:"60",className:"w-full p-2 border border-gray-300 rounded-md"})]}),e.jsxs("div",{children:[e.jsx("label",{className:"block text-sm font-medium text-gray-700 mb-2",children:"最大请求数"}),e.jsx("input",{type:"number",value:o,onChange:n=>c(parseInt(n.target.value)||5),min:"1",max:"50",className:"w-full p-2 border border-gray-300 rounded-md"})]})]}),d&&e.jsxs("div",{className:"mb-4 p-4 bg-green-50 rounded-lg",children:[e.jsx("h4",{className:"font-medium text-green-900 mb-2",children:"滑动窗口状态"}),e.jsx("div",{className:"flex items-center space-x-4",children:e.jsxs("div",{className:"flex-1",children:[e.jsxs("div",{className:"flex justify-between text-sm text-green-700 mb-1",children:[e.jsx("span",{children:"当前窗口请求数"}),e.jsxs("span",{children:[d.currentCount," / ",d.maxRequests]})]}),e.jsx("div",{className:"w-full bg-green-200 rounded-full h-2",children:e.jsx("div",{className:"bg-green-600 h-2 rounded-full transition-all duration-300",style:{width:`${d.currentCount/d.maxRequests*100}%`}})})]})})]}),e.jsxs("div",{className:"flex space-x-4 mb-4",children:[e.jsx("button",{onClick:r,className:"px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700",children:"发送请求"}),e.jsx("button",{onClick:w,className:"px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700",children:"连续请求 (8秒)"}),e.jsx("button",{onClick:a,className:"px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700",children:"重置"})]}),h.length>0&&e.jsxs("div",{children:[e.jsx("h4",{className:"font-medium text-gray-900 mb-2",children:"请求日志"}),e.jsx("div",{className:"space-y-1 max-h-40 overflow-y-auto",children:h.map((n,g)=>e.jsxs("div",{className:`flex justify-between items-center p-2 rounded text-sm ${n.allowed?"bg-green-100 text-green-800":"bg-red-100 text-red-800"}`,children:[e.jsx("span",{children:n.time}),e.jsx("span",{children:n.allowed?"✅ 允许":"❌ 拒绝"})]},g))})]})]})})},E=()=>{const[i]=l.useState(()=>new N),[s]=l.useState([{key:"token-bucket",name:"令牌桶",color:"blue"},{key:"sliding-window",name:"滑动窗口",color:"green"},{key:"fixed-window",name:"固定窗口",color:"purple"}]),[t,o]=l.useState({}),[c,d]=l.useState({}),j=l.useRef(null);l.useEffect(()=>{i.createTokenBucket("token-bucket",5,1),i.createSlidingWindow("sliding-window",10,5),i.createFixedWindow("fixed-window",10,5);const r={};s.forEach(a=>{r[a.key]=[]}),d(r),h()},[]),l.useEffect(()=>(j.current=setInterval(h,100),()=>{j.current&&clearInterval(j.current)}),[]);const h=l.useCallback(()=>{const r={};s.forEach(a=>{r[a.key]=i.getLimiterStatus(a.key)}),o(r)},[i,s]),b=l.useCallback(()=>{const r={...c};s.forEach(a=>{const w=i.checkRequest(a.key),n={time:new Date().toLocaleTimeString(),allowed:w};r[a.key]=[n,...r[a.key].slice(0,4)]}),d(r),h()},[i,s,c,h]),p=l.useCallback(()=>{s.forEach(a=>{i.resetLimiter(a.key)});const r={};s.forEach(a=>{r[a.key]=[]}),d(r),h()},[i,s,h]),x=l.useCallback(()=>{for(let r=0;r<10;r++)setTimeout(()=>b(),r*200)},[b]),u=r=>{const a={blue:{bg:"bg-blue-50",text:"text-blue-900",border:"border-blue-200",button:"bg-blue-600 hover:bg-blue-700"},green:{bg:"bg-green-50",text:"text-green-900",border:"border-green-200",button:"bg-green-600 hover:bg-green-700"},purple:{bg:"bg-purple-50",text:"text-purple-900",border:"border-purple-200",button:"bg-purple-600 hover:bg-purple-700"}};return a[r]||a.blue};return e.jsx("div",{className:"space-y-4",children:e.jsxs("div",{className:"bg-white p-6 rounded-lg border",children:[e.jsx("h3",{className:"text-lg font-semibold mb-4",children:"限流算法对比"}),e.jsxs("div",{className:"flex space-x-4 mb-6",children:[e.jsx("button",{onClick:b,className:"px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700",children:"发送请求到所有算法"}),e.jsx("button",{onClick:x,className:"px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700",children:"压力测试 (10个请求)"}),e.jsx("button",{onClick:p,className:"px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700",children:"重置所有"})]}),e.jsx("div",{className:"grid grid-cols-1 md:grid-cols-3 gap-4",children:s.map(r=>{const a=t[r.key],w=c[r.key]||[],n=u(r.color);return e.jsxs("div",{className:`p-4 rounded-lg border ${n.bg} ${n.border}`,children:[e.jsx("h4",{className:`font-medium mb-3 ${n.text}`,children:r.name}),a&&e.jsxs("div",{className:"mb-3",children:[a.type==="TokenBucket"&&e.jsxs("div",{children:[e.jsxs("div",{className:`text-sm mb-1 ${n.text}`,children:["令牌: ",a.tokens," / ",a.capacity]}),e.jsx("div",{className:"w-full bg-gray-200 rounded-full h-2",children:e.jsx("div",{className:`h-2 rounded-full transition-all duration-300 ${r.color==="blue"?"bg-blue-600":r.color==="green"?"bg-green-600":"bg-purple-600"}`,style:{width:`${a.tokens/a.capacity*100}%`}})})]}),(a.type==="SlidingWindow"||a.type==="FixedWindow")&&e.jsxs("div",{children:[e.jsxs("div",{className:`text-sm mb-1 ${n.text}`,children:["请求: ",a.currentCount," / ",a.maxRequests]}),e.jsx("div",{className:"w-full bg-gray-200 rounded-full h-2",children:e.jsx("div",{className:`h-2 rounded-full transition-all duration-300 ${r.color==="blue"?"bg-blue-600":r.color==="green"?"bg-green-600":"bg-purple-600"}`,style:{width:`${a.currentCount/a.maxRequests*100}%`}})})]})]}),e.jsxs("div",{children:[e.jsx("div",{className:`text-sm font-medium mb-2 ${n.text}`,children:"最近请求"}),e.jsx("div",{className:"space-y-1",children:w.length===0?e.jsx("div",{className:"text-xs text-gray-500",children:"暂无请求"}):w.map((g,f)=>e.jsxs("div",{className:`flex justify-between items-center p-1 rounded text-xs ${g.allowed?"bg-green-100 text-green-800":"bg-red-100 text-red-800"}`,children:[e.jsx("span",{children:g.time}),e.jsx("span",{children:g.allowed?"✅":"❌"})]},f))})]})]},r.key)})}),e.jsxs("div",{className:"mt-6 p-4 bg-gray-50 rounded-lg",children:[e.jsx("h4",{className:"font-medium text-gray-900 mb-2",children:"算法特点对比"}),e.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-3 gap-4 text-sm",children:[e.jsxs("div",{children:[e.jsx("div",{className:"font-medium text-blue-900 mb-1",children:"令牌桶"}),e.jsxs("ul",{className:"text-gray-700 space-y-1",children:[e.jsx("li",{children:"• 允许突发流量"}),e.jsx("li",{children:"• 平滑限流"}),e.jsx("li",{children:"• 内存占用小"})]})]}),e.jsxs("div",{children:[e.jsx("div",{className:"font-medium text-green-900 mb-1",children:"滑动窗口"}),e.jsxs("ul",{className:"text-gray-700 space-y-1",children:[e.jsx("li",{children:"• 精确限流"}),e.jsx("li",{children:"• 无边界效应"}),e.jsx("li",{children:"• 内存占用较大"})]})]}),e.jsxs("div",{children:[e.jsx("div",{className:"font-medium text-purple-900 mb-1",children:"固定窗口"}),e.jsxs("ul",{className:"text-gray-700 space-y-1",children:[e.jsx("li",{children:"• 实现简单"}),e.jsx("li",{children:"• 内存占用小"}),e.jsx("li",{children:"• 存在边界效应"})]})]})]})]})]})})},I=()=>{const i={title:"令牌桶算法实现",language:"typescript",code:`// 令牌桶算法实现
class TokenBucket {
  private capacity: number;
  private tokens: number;
  private refillRate: number;
  private lastRefill: number;

  constructor(capacity: number, refillRate: number) {
    this.capacity = capacity;
    this.tokens = capacity;
    this.refillRate = refillRate; // tokens per second
    this.lastRefill = Date.now();
  }

  // 尝试消费令牌
  consume(tokens: number = 1): boolean {
    this.refill();

    if (this.tokens >= tokens) {
      this.tokens -= tokens;
      return true;
    }

    return false;
  }

  // 补充令牌
  private refill(): void {
    const now = Date.now();
    const timePassed = (now - this.lastRefill) / 1000;
    const tokensToAdd = timePassed * this.refillRate;

    this.tokens = Math.min(this.capacity, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }

  // 获取当前令牌数
  getTokens(): number {
    this.refill();
    return Math.floor(this.tokens);
  }
}`,highlights:[15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34]};return e.jsx(C,{title:"请求限流控制",description:"实现多种限流算法保护系统免受过载，包括令牌桶、滑动窗口和固定窗口算法。",overview:e.jsxs("div",{className:"space-y-4",children:[e.jsxs("div",{className:"bg-blue-50 p-6 rounded-lg",children:[e.jsx("h3",{className:"text-lg font-semibold text-blue-900 mb-3",children:"🚦 核心概念"}),e.jsxs("ul",{className:"space-y-2 text-blue-800",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"令牌桶算法:"})," ","以固定速率生成令牌，允许突发流量但限制平均速率"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"滑动窗口:"})," ","在时间窗口内限制请求数量，提供精确的流量控制"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"固定窗口:"})," ","在固定时间段内限制请求数量，实现简单但有边界效应"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"限流策略:"})," 根据不同场景选择合适的限流算法和参数"]})]})]}),e.jsxs("div",{className:"bg-green-50 p-6 rounded-lg",children:[e.jsx("h3",{className:"text-lg font-semibold text-green-900 mb-3",children:"✨ 主要优势"}),e.jsxs("ul",{className:"space-y-2 text-green-800",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"系统保护:"})," 防止系统过载，保证服务稳定性"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"资源控制:"})," 合理分配系统资源，避免资源耗尽"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"用户体验:"})," 保证正常用户的服务质量"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"成本控制:"})," 避免因流量激增导致的成本飙升"]})]})]}),e.jsxs("div",{className:"bg-yellow-50 p-6 rounded-lg",children:[e.jsx("h3",{className:"text-lg font-semibold text-yellow-900 mb-3",children:"🎯 适用场景"}),e.jsxs("ul",{className:"space-y-2 text-yellow-800",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"API网关:"})," 限制API调用频率，防止滥用"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Web服务:"})," 控制用户请求频率，防止恶意攻击"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"数据库访问:"})," 限制数据库查询频率，保护数据库性能"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"第三方服务:"})," 遵守第三方API的调用限制"]})]})]}),e.jsxs("div",{className:"bg-red-50 p-6 rounded-lg",children:[e.jsx("h3",{className:"text-lg font-semibold text-red-900 mb-3",children:"⚠️ 注意事项"}),e.jsxs("ul",{className:"space-y-2 text-red-800",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"参数调优:"})," 根据实际业务需求调整限流参数"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"用户体验:"})," 避免过于严格的限流影响正常用户"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"监控告警:"})," 建立完善的监控和告警机制"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"降级策略:"})," 制定限流触发时的降级方案"]})]})]})]}),examples:[{title:"令牌桶算法",component:e.jsx(T,{}),description:"演示令牌桶算法的工作原理，支持突发流量但限制平均速率。",observationPoints:["调整桶容量和补充速率，观察限流效果的变化",'点击"突发请求"按钮，观察令牌桶如何处理突发流量',"令牌会以固定速率补充，直到达到桶的容量上限","当令牌不足时，请求会被拒绝"],keyPoints:["令牌桶允许一定程度的突发流量","平均速率由令牌补充速率决定","桶容量决定了最大突发流量","适合需要处理突发请求的场景"],commonTraps:["桶容量设置过大导致突发流量过多","补充速率设置不当影响系统性能","忽略令牌补充的时间精度","没有考虑系统时钟的影响"],solutions:["根据系统承载能力设置合理的桶容量","通过压力测试确定最优的补充速率","使用高精度时间戳进行令牌计算","考虑使用分布式时钟同步"],codeExample:i},{title:"滑动窗口算法",component:e.jsx(W,{}),description:"演示滑动窗口算法的精确限流机制，无边界效应问题。",observationPoints:["调整窗口大小和最大请求数，观察限流精度",'点击"连续请求"按钮，观察滑动窗口的时间特性',"过期的请求记录会自动从窗口中移除","窗口是连续滑动的，没有固定的重置时间点"],keyPoints:["滑动窗口提供精确的流量控制","没有固定窗口的边界效应问题","内存占用与请求频率成正比","适合需要精确限流的场景"],importantTips:["滑动窗口需要存储每个请求的时间戳","内存占用会随着请求频率增加","需要定期清理过期的请求记录","在高并发场景下要注意性能优化"],commonTraps:["忽略过期请求记录的清理导致内存泄漏","时间戳精度不够影响限流准确性","高并发下数组操作性能问题","窗口大小设置不合理"],solutions:["定期清理过期的请求记录","使用高精度时间戳","考虑使用更高效的数据结构","根据业务需求合理设置窗口大小"],codeExample:S},{title:"算法对比演示",component:e.jsx(E,{}),description:"对比三种限流算法的特点和行为差异，帮助选择合适的算法。",observationPoints:["同时向三种算法发送请求，观察不同的响应行为","令牌桶允许突发请求，其他算法更严格","固定窗口在窗口重置时会允许新的请求","滑动窗口提供最平滑的限流效果"],keyPoints:["令牌桶适合允许突发流量的场景","滑动窗口适合需要精确控制的场景","固定窗口实现简单但有边界效应","选择算法需要权衡性能和精度"],commonTraps:["选择算法时只考虑实现复杂度","忽略不同算法的内存占用差异","没有考虑业务场景的特殊需求","缺乏对算法行为的深入理解"],solutions:["根据业务需求选择合适的限流算法","考虑内存、CPU和精度的权衡","进行充分的测试验证算法效果","建立监控机制观察限流效果"],importantTips:["令牌桶适合突发流量场景","滑动窗口提供最精确的限流","固定窗口实现最简单但有边界效应","选择算法要考虑业务特点和性能要求"],codeExample:L}],tutorial:{concepts:["限流是保护系统免受过载的重要手段，通过控制请求速率维护系统稳定性","令牌桶算法通过令牌生成和消费机制实现流量控制，允许一定的突发流量","滑动窗口算法在时间窗口内精确计数，提供平滑的限流效果","固定窗口算法实现简单但存在边界效应，可能导致瞬时流量翻倍","限流参数需要根据系统容量和业务需求进行调优"],steps:["分析系统容量和性能瓶颈","选择合适的限流算法","设计限流参数和策略","实现限流逻辑和状态管理","集成到请求处理流程中","建立监控和告警机制","实现限流触发时的处理逻辑","进行压力测试验证效果","根据监控数据调优参数"],tips:["令牌桶适合API网关等需要处理突发流量的场景","滑动窗口适合对精度要求高的业务场景","固定窗口适合对性能要求高且可以容忍边界效应的场景","限流参数应该基于系统实际容量而不是理论值","建立多层限流机制，包括用户级、IP级和全局限流","考虑限流的公平性，避免某些用户占用过多资源"]},interview:{questions:[{question:"令牌桶和漏桶算法有什么区别？",answer:"主要区别：1) 令牌桶允许突发流量，漏桶严格控制输出速率；2) 令牌桶在有令牌时可以立即处理请求，漏桶按固定速率处理；3) 令牌桶适合允许突发的场景，漏桶适合需要平滑输出的场景；4) 令牌桶的突发能力由桶容量决定，漏桶没有突发能力。"},{question:"滑动窗口和固定窗口的优缺点是什么？",answer:"滑动窗口优点：精确限流、无边界效应、平滑控制；缺点：内存占用大、实现复杂。固定窗口优点：实现简单、内存占用小、性能好；缺点：存在边界效应、可能出现瞬时流量翻倍、限流不够精确。"},{question:"如何选择合适的限流算法？",answer:"选择依据：1) 业务特性：是否需要处理突发流量；2) 精度要求：是否需要精确的流量控制；3) 性能要求：系统的内存和CPU资源情况；4) 实现复杂度：开发和维护成本；5) 监控需求：是否需要详细的流量统计。一般来说，API网关用令牌桶，精确控制用滑动窗口，简单场景用固定窗口。"},{question:"分布式系统中如何实现限流？",answer:"分布式限流方案：1) 集中式：使用Redis等中心化存储维护限流状态；2) 分布式：每个节点独立限流，总限制按节点数分配；3) 一致性哈希：根据用户ID等维度路由到固定节点；4) 滑动窗口日志：使用分布式日志系统记录请求；5) 令牌分发：中心节点分发令牌到各个服务节点。需要考虑网络延迟、数据一致性和故障恢复。"}],keyPoints:["限流算法的选择需要权衡精度、性能和复杂度","令牌桶允许突发流量，适合大多数Web应用场景","滑动窗口提供最精确的限流，但内存开销较大","固定窗口实现简单但存在边界效应问题","分布式限流需要考虑一致性和性能问题","限流参数需要根据实际业务负载进行调优","建立完善的监控和告警机制非常重要"]},bestPractices:{dos:["根据业务场景选择合适的限流算法","设置合理的限流参数和阈值","建立多层限流机制（用户级、IP级、全局）","实现优雅的限流响应和错误处理","建立完善的监控和告警系统","定期评估和调整限流策略","考虑限流的公平性和用户体验","实现限流状态的持久化和恢复"],donts:["不要设置过于严格的限流参数","不要忽略限流对用户体验的影响","不要在没有监控的情况下部署限流","不要使用单一的限流策略","不要忽略分布式环境下的一致性问题","不要在高并发路径上使用复杂的限流逻辑","不要忘记处理限流器的异常情况","不要忽略限流数据的清理和维护"],patterns:["分层限流模式：用户级、应用级、系统级多层保护","自适应限流模式：根据系统负载动态调整限流参数","熔断限流模式：结合熔断器实现故障保护","预热限流模式：系统启动时逐步放开流量","优先级限流模式：对不同优先级的请求采用不同策略","地域限流模式：根据地理位置实施差异化限流","时间窗口限流模式：根据时间段调整限流策略"]}})};export{I as default};
