var w=Object.defineProperty;var S=(n,r,s)=>r in n?w(n,r,{enumerable:!0,configurable:!0,writable:!0,value:s}):n[r]=s;var u=(n,r,s)=>S(n,typeof r!="symbol"?r+"":r,s);import{r as i,j as e,R as U}from"./index-CKH9Ek1I.js";import{C as E}from"./ComponentTemplate-B8dTsNLj.js";class $ extends i.Component{constructor(s){super(s);u(this,"renderCount",0);u(this,"handleIncrement",()=>{this.setState(s=>({count:s.count+s.step}))});u(this,"handleDecrement",()=>{this.setState(s=>({count:s.count-s.step}))});u(this,"handleStepChange",s=>{const o=parseInt(s.target.value)||1;this.setState({step:o})});u(this,"handleReset",()=>{this.setState({count:0,step:1})});this.state={count:0,step:1}}componentDidMount(){console.log(`${this.props.title} - 组件已挂载`)}componentDidUpdate(s,o){o.count!==this.state.count&&console.log(`${this.props.title} - 计数更新: ${o.count} -> ${this.state.count}`)}componentWillUnmount(){console.log(`${this.props.title} - 组件将卸载`)}render(){var c,t;this.renderCount++,(t=(c=this.props).onRenderCount)==null||t.call(c,this.renderCount);const{count:s,step:o}=this.state,{title:l}=this.props;return e.jsxs("div",{className:"bg-blue-50 p-6 rounded-lg border border-blue-200",children:[e.jsxs("h3",{className:"text-lg font-semibold text-blue-800 mb-4 flex items-center",children:["🏛️ ",l,e.jsxs("span",{className:"ml-2 text-sm bg-blue-100 px-2 py-1 rounded",children:["渲染次数: ",this.renderCount]})]}),e.jsxs("div",{className:"space-y-4",children:[e.jsxs("div",{className:"text-center",children:[e.jsx("div",{className:"text-3xl font-bold text-blue-600 mb-2",children:s}),e.jsxs("div",{className:"text-sm text-blue-500",children:["当前步长: ",o]})]}),e.jsxs("div",{className:"flex gap-2 justify-center",children:[e.jsxs("button",{onClick:this.handleDecrement,className:"px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors",children:["-",o]}),e.jsxs("button",{onClick:this.handleIncrement,className:"px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors",children:["+",o]})]}),e.jsxs("div",{className:"flex gap-2 items-center justify-center",children:[e.jsx("label",{className:"text-sm text-blue-600",children:"步长:"}),e.jsx("input",{type:"number",value:o,onChange:this.handleStepChange,className:"w-16 px-2 py-1 border border-blue-300 rounded text-center",min:"1"})]}),e.jsx("div",{className:"text-center",children:e.jsx("button",{onClick:this.handleReset,className:"px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors",children:"重置"})})]}),e.jsxs("div",{className:"mt-4 text-xs text-blue-500 space-y-1",children:[e.jsx("div",{children:"• 使用 class 组件和 this.state"}),e.jsx("div",{children:"• 生命周期方法处理副作用"}),e.jsx("div",{children:"• 方法需要手动绑定 this"})]})]})}}const V=({title:n,onRenderCount:r})=>{const[s,o]=i.useState(0),[l,c]=i.useState(1),t=i.useRef(0);i.useEffect(()=>{console.log(`${n} - 组件已挂载或更新`)}),i.useEffect(()=>(console.log(`${n} - 组件已挂载`),()=>{console.log(`${n} - 组件将卸载`)}),[n]),i.useEffect(()=>{t.current>0&&console.log(`${n} - 计数更新: ${s}`)},[s,n]),t.current++,r==null||r(t.current);const x=()=>{o(m=>m+l)},h=()=>{o(m=>m-l)},d=m=>{const j=parseInt(m.target.value)||1;c(j)},b=()=>{o(0),c(1)};return e.jsxs("div",{className:"bg-green-50 p-6 rounded-lg border border-green-200",children:[e.jsxs("h3",{className:"text-lg font-semibold text-green-800 mb-4 flex items-center",children:["🎣 ",n,e.jsxs("span",{className:"ml-2 text-sm bg-green-100 px-2 py-1 rounded",children:["渲染次数: ",t.current]})]}),e.jsxs("div",{className:"space-y-4",children:[e.jsxs("div",{className:"text-center",children:[e.jsx("div",{className:"text-3xl font-bold text-green-600 mb-2",children:s}),e.jsxs("div",{className:"text-sm text-green-500",children:["当前步长: ",l]})]}),e.jsxs("div",{className:"flex gap-2 justify-center",children:[e.jsxs("button",{onClick:h,className:"px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors",children:["-",l]}),e.jsxs("button",{onClick:x,className:"px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors",children:["+",l]})]}),e.jsxs("div",{className:"flex gap-2 items-center justify-center",children:[e.jsx("label",{className:"text-sm text-green-600",children:"步长:"}),e.jsx("input",{type:"number",value:l,onChange:d,className:"w-16 px-2 py-1 border border-green-300 rounded text-center",min:"1"})]}),e.jsx("div",{className:"text-center",children:e.jsx("button",{onClick:b,className:"px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors",children:"重置"})})]}),e.jsxs("div",{className:"mt-4 text-xs text-green-500 space-y-1",children:[e.jsx("div",{children:"• 使用 useState 管理状态"}),e.jsx("div",{children:"• useEffect 处理副作用"}),e.jsx("div",{children:"• 函数式组件，无需绑定 this"})]})]})},D=[{id:1,name:"Alice Johnson",email:"alice@example.com",status:"active"},{id:2,name:"Bob Smith",email:"bob@example.com",status:"inactive"},{id:3,name:"Charlie Brown",email:"charlie@example.com",status:"active"},{id:4,name:"Diana Prince",email:"diana@example.com",status:"active"},{id:5,name:"Edward Norton",email:"edward@example.com",status:"inactive"}],P=[{aspect:"代码量",classComponent:"通常需要更多样板代码",hooksComponent:"代码更简洁，减少样板代码",advantage:"hooks"},{aspect:"状态管理",classComponent:"使用 this.state 和 this.setState",hooksComponent:"使用 useState 和 useReducer",advantage:"hooks"},{aspect:"生命周期",classComponent:"明确的生命周期方法",hooksComponent:"使用 useEffect 统一处理",advantage:"equal"},{aspect:"逻辑复用",classComponent:"使用 HOC 或 Render Props",hooksComponent:"使用自定义 Hooks",advantage:"hooks"},{aspect:"性能优化",classComponent:"使用 shouldComponentUpdate 或 PureComponent",hooksComponent:"使用 React.memo、useMemo、useCallback",advantage:"equal"},{aspect:"学习曲线",classComponent:"OOP 概念，this 绑定复杂",hooksComponent:"函数式编程，更直观",advantage:"hooks"},{aspect:"测试友好性",classComponent:"需要实例化，测试相对复杂",hooksComponent:"纯函数，测试更简单",advantage:"hooks"},{aspect:"错误边界",classComponent:"支持 componentDidCatch",hooksComponent:"目前不支持错误边界",advantage:"class"}],M=[{name:"初始渲染时间",classValue:2.3,hooksValue:1.8,unit:"ms",description:"组件首次渲染所需时间"},{name:"重渲染时间",classValue:1.5,hooksValue:1.2,unit:"ms",description:"状态更新后重新渲染时间"},{name:"内存使用",classValue:45,hooksValue:38,unit:"KB",description:"组件实例占用的内存大小"},{name:"包大小影响",classValue:12,hooksValue:8,unit:"KB",description:"对最终打包大小的影响"}],f=()=>new Promise(n=>{setTimeout(()=>{n(D)},1e3)}),k=n=>new Promise(r=>{setTimeout(()=>{const s={...n,id:Date.now()};r(s)},500)}),N=n=>new Promise(r=>{setTimeout(()=>{r()},300)}),R=n=>{switch(n){case"class":return"text-blue-600 bg-blue-50";case"hooks":return"text-green-600 bg-green-50";case"equal":return"text-gray-600 bg-gray-50";default:return"text-gray-600 bg-gray-50"}},T=n=>{switch(n){case"class":return"🏛️";case"hooks":return"🎣";case"equal":return"⚖️";default:return"⚖️"}};class q extends i.Component{constructor(s){super(s);u(this,"renderCount",0);u(this,"mounted",!1);u(this,"loadUsers",async()=>{this.setState({loading:!0,error:null});try{const s=await f();this.mounted&&this.setState({users:s,loading:!1})}catch(s){this.mounted&&this.setState({error:s instanceof Error?s.message:"加载用户失败",loading:!1})}});u(this,"handleAddUser",async()=>{const s=prompt("请输入用户名:"),o=prompt("请输入邮箱:");if(!(!s||!o)){this.setState({loading:!0});try{const l=await k({name:s,email:o,status:"active"});this.mounted&&this.setState(c=>({users:[...c.users,l],loading:!1}))}catch(l){this.mounted&&this.setState({error:l instanceof Error?l.message:"添加用户失败",loading:!1})}}});u(this,"handleDeleteUser",async s=>{if(confirm("确定要删除这个用户吗？")){this.setState({loading:!0});try{await N(s),this.mounted&&this.setState(o=>({users:o.users.filter(l=>l.id!==s),loading:!1}))}catch(o){this.mounted&&this.setState({error:o instanceof Error?o.message:"删除用户失败",loading:!1})}}});u(this,"handleFilterChange",s=>{this.setState({filter:s})});u(this,"getFilteredUsers",()=>{const{users:s,filter:o}=this.state;return o==="all"?s:s.filter(l=>l.status===o)});this.state={users:[],loading:!1,error:null,filter:"all"}}async componentDidMount(){this.mounted=!0,console.log(`${this.props.title} - 组件已挂载，开始加载用户`),await this.loadUsers()}componentWillUnmount(){this.mounted=!1,console.log(`${this.props.title} - 组件将卸载`)}render(){var x,h;this.renderCount++,(h=(x=this.props).onRenderCount)==null||h.call(x,this.renderCount);const{loading:s,error:o,filter:l}=this.state,{title:c}=this.props,t=this.getFilteredUsers();return e.jsxs("div",{className:"bg-blue-50 p-6 rounded-lg border border-blue-200",children:[e.jsxs("h3",{className:"text-lg font-semibold text-blue-800 mb-4 flex items-center justify-between",children:[e.jsxs("span",{className:"flex items-center",children:["🏛️ ",c,e.jsxs("span",{className:"ml-2 text-sm bg-blue-100 px-2 py-1 rounded",children:["渲染次数: ",this.renderCount]})]}),e.jsx("button",{onClick:this.handleAddUser,disabled:s,className:"px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600 disabled:opacity-50",children:"添加用户"})]}),o&&e.jsx("div",{className:"mb-4 p-3 bg-red-100 border border-red-300 rounded text-red-700",children:o}),e.jsx("div",{className:"mb-4 flex gap-2",children:["all","active","inactive"].map(d=>e.jsx("button",{onClick:()=>this.handleFilterChange(d),className:`px-3 py-1 rounded text-sm ${l===d?"bg-blue-500 text-white":"bg-blue-100 text-blue-600 hover:bg-blue-200"}`,children:d==="all"?"全部":d==="active"?"活跃":"非活跃"},d))}),s?e.jsx("div",{className:"text-center py-4 text-blue-600",children:"加载中..."}):e.jsxs("div",{className:"space-y-2",children:[t.map(d=>e.jsxs("div",{className:"flex items-center justify-between p-3 bg-white rounded border border-blue-200",children:[e.jsxs("div",{children:[e.jsx("div",{className:"font-medium text-blue-800",children:d.name}),e.jsx("div",{className:"text-sm text-blue-600",children:d.email}),e.jsx("div",{className:`text-xs px-2 py-1 rounded inline-block ${d.status==="active"?"bg-green-100 text-green-600":"bg-gray-100 text-gray-600"}`,children:d.status==="active"?"活跃":"非活跃"})]}),e.jsx("button",{onClick:()=>this.handleDeleteUser(d.id),className:"px-2 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600",children:"删除"})]},d.id)),t.length===0&&e.jsx("div",{className:"text-center py-4 text-blue-500",children:"没有找到用户"})]}),e.jsxs("div",{className:"mt-4 text-xs text-blue-500 space-y-1",children:[e.jsx("div",{children:"• 使用 class 组件和生命周期方法"}),e.jsx("div",{children:"• componentDidMount 处理数据加载"}),e.jsx("div",{children:"• 需要手动管理组件挂载状态"})]})]})}}const F=({title:n,onRenderCount:r})=>{const[s,o]=i.useState([]),[l,c]=i.useState(!1),[t,x]=i.useState(null),[h,d]=i.useState("all"),b=i.useRef(0),m=i.useRef(!0);b.current++,r==null||r(b.current);const j=i.useCallback(async()=>{c(!0),x(null);try{const a=await f();m.current&&o(a)}catch(a){m.current&&x(a instanceof Error?a.message:"加载用户失败")}finally{m.current&&c(!1)}},[]);i.useEffect(()=>(console.log(`${n} - 组件已挂载，开始加载用户`),j(),()=>{m.current=!1,console.log(`${n} - 组件将卸载`)}),[n,j]);const y=i.useCallback(async()=>{const a=prompt("请输入用户名:"),p=prompt("请输入邮箱:");if(!(!a||!p)){c(!0);try{const g=await k({name:a,email:p,status:"active"});m.current&&o(C=>[...C,g])}catch(g){m.current&&x(g instanceof Error?g.message:"添加用户失败")}finally{m.current&&c(!1)}}},[]),H=i.useCallback(async a=>{if(confirm("确定要删除这个用户吗？")){c(!0);try{await N(a),m.current&&o(p=>p.filter(g=>g.id!==a))}catch(p){m.current&&x(p instanceof Error?p.message:"删除用户失败")}finally{m.current&&c(!1)}}},[]),v=s.filter(a=>h==="all"?!0:a.status===h);return e.jsxs("div",{className:"bg-green-50 p-6 rounded-lg border border-green-200",children:[e.jsxs("h3",{className:"text-lg font-semibold text-green-800 mb-4 flex items-center justify-between",children:[e.jsxs("span",{className:"flex items-center",children:["🎣 ",n,e.jsxs("span",{className:"ml-2 text-sm bg-green-100 px-2 py-1 rounded",children:["渲染次数: ",b.current]})]}),e.jsx("button",{onClick:y,disabled:l,className:"px-3 py-1 bg-green-500 text-white rounded text-sm hover:bg-green-600 disabled:opacity-50",children:"添加用户"})]}),t&&e.jsx("div",{className:"mb-4 p-3 bg-red-100 border border-red-300 rounded text-red-700",children:t}),e.jsx("div",{className:"mb-4 flex gap-2",children:["all","active","inactive"].map(a=>e.jsx("button",{onClick:()=>d(a),className:`px-3 py-1 rounded text-sm ${h===a?"bg-green-500 text-white":"bg-green-100 text-green-600 hover:bg-green-200"}`,children:a==="all"?"全部":a==="active"?"活跃":"非活跃"},a))}),l?e.jsx("div",{className:"text-center py-4 text-green-600",children:"加载中..."}):e.jsxs("div",{className:"space-y-2",children:[v.map(a=>e.jsxs("div",{className:"flex items-center justify-between p-3 bg-white rounded border border-green-200",children:[e.jsxs("div",{children:[e.jsx("div",{className:"font-medium text-green-800",children:a.name}),e.jsx("div",{className:"text-sm text-green-600",children:a.email}),e.jsx("div",{className:`text-xs px-2 py-1 rounded inline-block ${a.status==="active"?"bg-green-100 text-green-600":"bg-gray-100 text-gray-600"}`,children:a.status==="active"?"活跃":"非活跃"})]}),e.jsx("button",{onClick:()=>H(a.id),className:"px-2 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600",children:"删除"})]},a.id)),v.length===0&&e.jsx("div",{className:"text-center py-4 text-green-500",children:"没有找到用户"})]}),e.jsxs("div",{className:"mt-4 text-xs text-green-500 space-y-1",children:[e.jsx("div",{children:"• 使用 useState 和 useEffect"}),e.jsx("div",{children:"• useCallback 优化函数引用"}),e.jsx("div",{children:"• useRef 管理组件挂载状态"})]})]})},A=()=>{const[n,r]=i.useState("features"),[s,o]=i.useState(null),l=()=>e.jsxs("div",{className:"space-y-4",children:[e.jsx("div",{className:"grid gap-4",children:P.map((t,x)=>e.jsxs("div",{className:"bg-white p-4 rounded-lg border border-gray-200 hover:shadow-md transition-shadow cursor-pointer",onClick:()=>o(t),children:[e.jsxs("div",{className:"flex items-center justify-between mb-3",children:[e.jsx("h4",{className:"font-semibold text-gray-800",children:t.aspect}),e.jsxs("div",{className:`px-2 py-1 rounded text-xs font-medium ${R(t.advantage)}`,children:[T(t.advantage),t.advantage==="class"?"类组件优势":t.advantage==="hooks"?"Hooks 优势":"相当"]})]}),e.jsxs("div",{className:"grid md:grid-cols-2 gap-4",children:[e.jsxs("div",{className:"bg-blue-50 p-3 rounded border border-blue-200",children:[e.jsx("div",{className:"text-sm font-medium text-blue-800 mb-1",children:"🏛️ 类组件"}),e.jsx("div",{className:"text-sm text-blue-600",children:t.classComponent})]}),e.jsxs("div",{className:"bg-green-50 p-3 rounded border border-green-200",children:[e.jsx("div",{className:"text-sm font-medium text-green-800 mb-1",children:"🎣 Hooks"}),e.jsx("div",{className:"text-sm text-green-600",children:t.hooksComponent})]})]})]},x))}),s&&e.jsxs("div",{className:"mt-6 p-4 bg-gray-50 rounded-lg border border-gray-200",children:[e.jsxs("h4",{className:"font-semibold text-gray-800 mb-2",children:["详细对比: ",s.aspect]}),e.jsxs("div",{className:"grid md:grid-cols-2 gap-4",children:[e.jsxs("div",{children:[e.jsx("h5",{className:"font-medium text-blue-800 mb-2",children:"🏛️ 类组件特点"}),e.jsxs("ul",{className:"text-sm text-blue-600 space-y-1",children:[e.jsx("li",{children:"• 基于 ES6 类语法"}),e.jsx("li",{children:"• 明确的生命周期方法"}),e.jsx("li",{children:"• this 上下文绑定"}),e.jsx("li",{children:"• 支持错误边界"})]})]}),e.jsxs("div",{children:[e.jsx("h5",{className:"font-medium text-green-800 mb-2",children:"🎣 Hooks 特点"}),e.jsxs("ul",{className:"text-sm text-green-600 space-y-1",children:[e.jsx("li",{children:"• 函数式编程范式"}),e.jsx("li",{children:"• 更简洁的代码"}),e.jsx("li",{children:"• 更好的逻辑复用"}),e.jsx("li",{children:"• 更容易测试"})]})]})]})]})]}),c=()=>e.jsxs("div",{className:"space-y-4",children:[e.jsxs("div",{className:"bg-white p-4 rounded-lg border border-gray-200",children:[e.jsx("h4",{className:"font-semibold text-gray-800 mb-4",children:"性能对比分析"}),e.jsx("div",{className:"space-y-4",children:M.map((t,x)=>e.jsxs("div",{className:"border border-gray-200 rounded-lg p-4",children:[e.jsxs("div",{className:"flex items-center justify-between mb-3",children:[e.jsx("h5",{className:"font-medium text-gray-800",children:t.name}),e.jsx("div",{className:"text-sm text-gray-500",children:t.description})]}),e.jsxs("div",{className:"grid md:grid-cols-2 gap-4",children:[e.jsxs("div",{className:"bg-blue-50 p-3 rounded",children:[e.jsx("div",{className:"text-sm font-medium text-blue-800 mb-1",children:"🏛️ 类组件"}),e.jsxs("div",{className:"text-2xl font-bold text-blue-600",children:[t.classValue," ",t.unit]})]}),e.jsxs("div",{className:"bg-green-50 p-3 rounded",children:[e.jsx("div",{className:"text-sm font-medium text-green-800 mb-1",children:"🎣 Hooks"}),e.jsxs("div",{className:"text-2xl font-bold text-green-600",children:[t.hooksValue," ",t.unit]})]})]}),e.jsx("div",{className:"mt-3 bg-gray-50 p-2 rounded",children:e.jsxs("div",{className:"text-sm text-gray-600",children:["性能提升:",e.jsx("span",{className:`font-medium ${t.hooksValue<t.classValue?"text-green-600":"text-red-600"}`,children:t.hooksValue<t.classValue?`+${((t.classValue-t.hooksValue)/t.classValue*100).toFixed(1)}%`:`-${((t.hooksValue-t.classValue)/t.classValue*100).toFixed(1)}%`})]})})]},x))})]}),e.jsxs("div",{className:"bg-yellow-50 p-4 rounded-lg border border-yellow-200",children:[e.jsx("h4",{className:"font-semibold text-yellow-800 mb-2",children:"性能分析说明"}),e.jsxs("ul",{className:"text-sm text-yellow-700 space-y-1",children:[e.jsx("li",{children:"• 数据基于典型使用场景的基准测试"}),e.jsx("li",{children:"• 实际性能可能因具体实现而异"}),e.jsx("li",{children:"• Hooks 通常在内存使用和包大小方面更优"}),e.jsx("li",{children:"• 类组件在某些复杂场景下可能更稳定"})]})]})]});return e.jsxs("div",{className:"space-y-6",children:[e.jsxs("div",{className:"flex gap-2 border-b border-gray-200",children:[e.jsx("button",{onClick:()=>r("features"),className:`px-4 py-2 font-medium text-sm border-b-2 transition-colors ${n==="features"?"border-blue-500 text-blue-600":"border-transparent text-gray-500 hover:text-gray-700"}`,children:"功能特性对比"}),e.jsx("button",{onClick:()=>r("performance"),className:`px-4 py-2 font-medium text-sm border-b-2 transition-colors ${n==="performance"?"border-blue-500 text-blue-600":"border-transparent text-gray-500 hover:text-gray-700"}`,children:"性能对比分析"})]}),n==="features"?l():c(),e.jsxs("div",{className:"bg-blue-50 p-4 rounded-lg border border-blue-200",children:[e.jsx("h4",{className:"font-semibold text-blue-800 mb-2",children:"选择建议"}),e.jsxs("div",{className:"grid md:grid-cols-2 gap-4 text-sm text-blue-700",children:[e.jsxs("div",{children:[e.jsx("h5",{className:"font-medium mb-2",children:"🏛️ 选择类组件的场景:"}),e.jsxs("ul",{className:"space-y-1",children:[e.jsx("li",{children:"• 需要错误边界功能"}),e.jsx("li",{children:"• 团队更熟悉 OOP 模式"}),e.jsx("li",{children:"• 现有大型类组件项目"}),e.jsx("li",{children:"• 需要精确的生命周期控制"})]})]}),e.jsxs("div",{children:[e.jsx("h5",{className:"font-medium mb-2",children:"🎣 选择 Hooks 的场景:"}),e.jsxs("ul",{className:"space-y-1",children:[e.jsx("li",{children:"• 新项目或新功能开发"}),e.jsx("li",{children:"• 需要更好的逻辑复用"}),e.jsx("li",{children:"• 追求更简洁的代码"}),e.jsx("li",{children:"• 函数式编程偏好"})]})]})]})]})]})},I=[{title:"核心概念",items:["函数组件 vs 类组件","Hooks 状态管理","生命周期对比","逻辑复用模式"]},{title:"主要优势",items:["更简洁的代码结构","更好的逻辑复用","更容易测试和理解","更好的 TypeScript 支持"]},{title:"适用场景",items:["新项目开发","逻辑复用需求","性能优化场景","渐进式迁移"]},{title:"注意事项",items:["遵循 Hooks 调用规则","正确处理依赖数组","理解闭包和状态更新","避免过度优化"]}],W=U.memo(()=>{const n=i.useMemo(()=>[{title:"基础功能对比",component:e.jsxs("div",{className:"grid grid-cols-1 lg:grid-cols-2 gap-6",children:[e.jsx($,{title:"类组件计数器"}),e.jsx(V,{title:"Hooks 计数器"})]}),description:"对比类组件和 Hooks 组件在实现相同功能时的代码差异。",observationPoints:["类组件需要 constructor、生命周期方法和 render 方法","Hooks 组件更简洁，使用 useState 和 useEffect","两者实现的功能完全相同","Hooks 版本代码量更少，更易读"],keyPoints:["useState 替代 this.state 和 this.setState","useEffect 替代生命周期方法","Hooks 版本更容易理解和维护","代码结构更清晰，逻辑更集中"],commonTraps:["认为 Hooks 比类组件复杂","不理解 Hooks 的调用规则","忽视依赖数组的重要性","过度使用 Hooks 优化"],solutions:["从简单的 useState 开始学习","仔细阅读 Hooks 规则文档","正确设置 useEffect 依赖数组","只在需要时使用性能优化 Hooks"]},{title:"复杂状态管理对比",component:e.jsxs("div",{className:"grid grid-cols-1 lg:grid-cols-2 gap-6",children:[e.jsx(q,{title:"类组件用户管理"}),e.jsx(F,{title:"Hooks 用户管理"})]}),description:"对比类组件和 Hooks 在复杂状态管理场景下的实现差异。",observationPoints:["类组件使用多个 state 属性和复杂的状态更新逻辑","Hooks 使用多个 useState 或 useReducer 管理状态","Hooks 版本状态逻辑更清晰，易于拆分","自定义 Hooks 可以更好地复用状态逻辑"],keyPoints:["useReducer 适合复杂状态逻辑","自定义 Hooks 封装状态管理","状态更新更可预测","逻辑复用更容易实现"],commonTraps:["在类组件中过度使用 this.setState","不理解 Hooks 的状态更新机制","忽视状态更新的异步特性","不合理的状态结构设计"],solutions:["使用函数式更新避免状态依赖","理解 Hooks 的状态更新时机","使用 useCallback 优化函数引用","设计合理的状态结构"]},{title:"综合对比分析",component:e.jsx(A,{}),description:"全面的对比分析，展示类组件和 Hooks 在各个方面的差异。",observationPoints:["性能对比显示 Hooks 版本通常更优","代码可读性 Hooks 版本明显更好","逻辑复用能力 Hooks 版本更强","学习曲线 Hooks 版本更平缓"],keyPoints:["Hooks 减少了组件间的耦合","更好的 TypeScript 支持","更容易进行单元测试","更符合函数式编程思想"],commonTraps:["认为类组件已经过时","盲目迁移所有类组件","不理解两种方式的适用场景","忽视团队的技术水平"],solutions:["根据项目需求选择合适方式","制定渐进式迁移策略","保持两种方式的兼容性","提升团队的技术能力"]}],[]),r=i.useMemo(()=>({concepts:["React Hooks 是函数组件使用状态和生命周期的解决方案","类组件和 Hooks 各有优势，适用于不同场景","Hooks 提供了更好的逻辑复用和组合能力","迁移到 Hooks 需要考虑团队能力和项目需求","两种方式可以共存，不需要完全替换"],steps:["理解 Hooks 和类组件的核心差异","学习 Hooks 的基本使用规则","掌握 useState 和 useEffect 的使用","学习自定义 Hooks 的创建方法","理解 Hooks 的性能优化策略","制定合适的迁移策略","在实际项目中应用 Hooks","持续学习和优化 Hooks 使用"],tips:["从简单的状态管理开始学习 Hooks","使用 ESLint 插件检查 Hooks 规则","理解 Hooks 的依赖数组机制","合理使用 useCallback 和 useMemo","关注 React 新版本中 Hooks 的改进"]}),[]),s=i.useMemo(()=>({questions:[{question:"React Hooks 相比类组件有什么优势？",answer:"Hooks 的主要优势包括：1) 更简洁的代码结构，减少了样板代码；2) 更好的逻辑复用，可以提取自定义 Hooks；3) 更容易理解和测试，逻辑更集中；4) 更好的 TypeScript 支持；5) 避免了 this 绑定的问题。"},{question:"什么时候应该使用类组件而不是 Hooks？",answer:"类组件仍然适用于：1) 需要错误边界的场景；2) 团队对类组件更熟悉的情况；3) 复杂的生命周期管理需求；4) 需要保持向后兼容性的项目。选择应该基于具体需求和团队能力。"},{question:"如何将类组件迁移到 Hooks？",answer:"迁移策略：1) 新功能优先使用 Hooks；2) 现有组件渐进式迁移；3) 从简单的状态管理开始；4) 使用自定义 Hooks 封装复杂逻辑；5) 保持两种方式的兼容性。建议制定详细的迁移计划和测试策略。"},{question:"Hooks 的性能如何？与类组件相比如何？",answer:"Hooks 通常具有更好的性能：1) 减少了组件实例的创建；2) 更好的树摇优化；3) 更精确的依赖管理；4) 减少了不必要的重渲染。但性能提升主要来自于更好的代码结构和优化策略，而不是 Hooks 本身。"},{question:"如何处理 Hooks 中的副作用？",answer:"使用 useEffect 处理副作用：1) 替代 componentDidMount、componentDidUpdate 等生命周期；2) 正确设置依赖数组控制执行时机；3) 返回清理函数处理组件卸载；4) 使用 useCallback 和 useMemo 优化性能。"}],keyPoints:["理解 Hooks 和类组件的核心差异和适用场景","掌握 Hooks 的基本使用规则和最佳实践","能够制定合适的迁移策略和实施方案","理解 Hooks 的性能特性和优化方法","能够创建和使用自定义 Hooks"]}),[]),o=i.useMemo(()=>({dos:["新项目优先使用 Hooks","渐进式迁移现有类组件","遵循 Hooks 的调用规则","使用自定义 Hooks 封装逻辑","正确设置 useEffect 依赖数组","合理使用性能优化 Hooks","保持代码的可读性和可维护性","关注 Hooks 的最佳实践"],donts:["不要盲目迁移所有类组件","不要违反 Hooks 的调用规则","不要过度使用性能优化 Hooks","不要忽视依赖数组的重要性","不要创建过于复杂的自定义 Hooks","不要忽视错误处理","不要在生产环境保留调试代码","不要忽视团队的技术水平"],patterns:["渐进式迁移：逐步引入 Hooks 到现有项目","自定义 Hooks：封装和复用组件逻辑","状态提升：将共享状态提升到公共父组件","逻辑分离：将相关逻辑分离到不同的 Hooks","性能优化：合理使用 useCallback 和 useMemo","错误边界：使用 ErrorBoundary 处理错误","测试策略：为 Hooks 编写充分的测试","代码规范：建立 Hooks 使用的代码规范"]}),[]);return e.jsx(E,{title:"Hooks vs 类组件对比",description:"深入对比 React Hooks 和类组件的差异，理解各自的优势和适用场景。",overview:I,examples:n,tutorial:r,interview:s,bestPractices:o})});export{W as default};
