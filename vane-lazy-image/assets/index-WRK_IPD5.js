function V(l={}){const{dwellMs:u=180,maxWaitMs:i=1e3,onlyWhenIntersecting:h=!0,debug:s=!1}=l,o="viewport-dwell:enteredAt",n="viewport-dwell:left",d=(e,t)=>{var r,a;try{(r=e.sharedData)==null||r.set(o,t)}catch{}try{(a=e.sharedData)==null||a.set(n,!1)}catch{}},f=(e,t)=>{var r;try{(r=e.sharedData)==null||r.set(n,t)}catch{}},D=e=>{var t;return(t=e.sharedData)==null?void 0:t.get(o)},g=e=>{var t;return!!((t=e.sharedData)!=null&&t.get(n))};return{name:"viewport-dwell",version:"1.0.0",config:l,hooks:{onBeforeLoad:async e=>{if(h&&!e.isIntersecting)return!0;const t=Date.now();let r=D(e);r||(r=t,d(e,r));const a=Date.now()-r,c=Math.max(0,u-a),w=Math.max(0,i);if(s)try{console.debug("[ViewportDwell] gating onBeforeLoad",{src:e.src,waitNeeded:c,waitBudget:w,elapsed:a})}catch{}if(c<=0)return!0;const p=E=>new Promise(L=>setTimeout(L,E)),y=Math.min(c,w);try{await p(y)}catch{}const m=g(e),v=Date.now()-t;if(m&&v<i){if(s)try{console.debug("[ViewportDwell] aborted due to leave",{src:e.src})}catch{}return!1}return!0},onEnterViewport:e=>{if(d(e,Date.now()),s)try{console.debug("[ViewportDwell] enter",{src:e.src})}catch{}},onLeaveViewport:e=>{if(f(e,!0),s)try{console.debug("[ViewportDwell] leave",{src:e.src})}catch{}},onLoad:e=>{},onUnmount:e=>{var t,r;try{(t=e.sharedData)==null||t.delete(o),(r=e.sharedData)==null||r.delete(n)}catch{}}}}}export{V as c};
