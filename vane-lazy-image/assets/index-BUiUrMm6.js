var pe=Object.defineProperty;var we=($,n,s)=>n in $?pe($,n,{enumerable:!0,configurable:!0,writable:!0,value:s}):$[n]=s;var K=($,n,s)=>we($,typeof n!="symbol"?n+"":n,s);import{r as m,R as N,j as T}from"./index-CAgh_i44.js";import{g as ne,a as re,c as be}from"./GlobalContext-DYUf_pwM.js";function ye($={}){const{debug:n=!1,warnUncleared:s=!1,batchEvents:o}=$,r=new Map,c=new Map,d=new Map,h=n?new WeakMap:null,S=new Map;let x=null;const U=o||new Set(["progress","scroll","resize"]),M=(e,a)=>new RegExp("^"+e.replace(/\*/g,".*").replace(/\?/g,".")+"$").test(a),q=(e,a)=>{const k=r.get(e);if(k)for(const p of k)try{p(a)}catch(f){console.warn(`[PluginBus] handler error for event "${e}"`,f)}for(const[p,f]of c.entries())if(M(p,e))for(const R of f)try{R(a)}catch(A){console.warn(`[PluginBus] wildcard handler error for pattern "${p}"`,A)}},I=()=>{S.forEach((e,a)=>{const k=e[e.length-1];q(a,k)}),S.clear(),x=null},H=(e,a)=>{U.has(e)?(S.has(e)||S.set(e,[]),S.get(e).push(a),x||(x=requestAnimationFrame(I))):q(e,a)},j=(e,a)=>{var p;if(h&&n)try{const f=new Error().stack,R=((p=f==null?void 0:f.split(`
`)[3])==null?void 0:p.trim().replace(/^at\s+/,""))||"unknown";h.set(a,R)}catch{}if(e.includes("*")||e.includes("?")){let f=c.get(e);return f||(f=new Set,c.set(e,f)),f.add(a),()=>{f==null||f.delete(a),(f==null?void 0:f.size)===0&&c.delete(e)}}else{let f=r.get(e);return f||(f=new Set,r.set(e,f)),f.add(a),()=>{f==null||f.delete(a),(f==null?void 0:f.size)===0&&r.delete(e)}}},t=(e,a)=>{const p=j(e,f=>{try{a(f)}finally{p()}});return p},l=(e,a)=>{if(!a)r.delete(e),c.delete(e);else{const k=r.get(e);k&&(k.delete(a),k.size===0&&r.delete(e));const p=c.get(e);p&&(p.delete(a),p.size===0&&c.delete(e))}},E=e=>{e?(r.delete(e),c.delete(e),S.delete(e)):(r.clear(),c.clear(),S.clear(),x&&(cancelAnimationFrame(x),x=null))},v=e=>d.get(e),P=(e,a)=>d.set(e,a),y=()=>{const e=[];return r.forEach((a,k)=>{const p=[];h&&n&&a.forEach(f=>{const R=h.get(f);R&&p.push(R)}),e.push({event:k,count:a.size,isWildcard:!1,sources:p.length>0?p:void 0})}),c.forEach((a,k)=>{const p=[];h&&n&&a.forEach(f=>{const R=h.get(f);R&&p.push(R)}),e.push({event:k,count:a.size,isWildcard:!0,sources:p.length>0?p:void 0})}),e},C=()=>({debug:n,warnUncleared:s,batchEvents:U});if(s&&typeof window<"u"){const e=()=>{const a=y();a.length>0&&console.warn(`[PluginBus] ${a.length} event listener(s) not cleared:`,a)};typeof window.addEventListener=="function"&&window.addEventListener("beforeunload",e)}return{emit:H,on:j,once:t,off:l,clear:E,getData:v,setData:P,getActiveListeners:y,getConfig:C}}class $e{constructor(){K(this,"dependencies");K(this,"optionalDependencies");K(this,"conflicts");this.dependencies=new Map,this.optionalDependencies=new Map,this.conflicts=new Map}addPlugin(n,s,o,r){s&&s.length>0&&this.dependencies.set(n,new Set(s)),o&&o.length>0&&this.optionalDependencies.set(n,new Set(o)),r&&r.length>0&&this.conflicts.set(n,new Set(r))}removePlugin(n){this.dependencies.delete(n),this.optionalDependencies.delete(n),this.conflicts.delete(n)}checkDependencies(n,s){const o=this.dependencies.get(n)||new Set,r=this.optionalDependencies.get(n)||new Set,c=Array.from(o).filter(h=>!s.has(h)),d=Array.from(r).filter(h=>!s.has(h));return{satisfied:c.length===0,missing:c,optional:d}}checkConflicts(n,s){const o=this.conflicts.get(n)||new Set,r=Array.from(o).filter(c=>s.has(c));return{hasConflict:r.length>0,conflicts:r}}detectCycles(){const n=[],s=new Set,o=new Set,r=(c,d)=>{if(o.has(c)){const S=d.indexOf(c);S!==-1&&n.push(d.slice(S).concat(c));return}if(s.has(c))return;s.add(c),o.add(c),d.push(c);const h=this.dependencies.get(c)||new Set;for(const S of h)r(S,[...d]);o.delete(c)};for(const c of this.dependencies.keys())s.has(c)||r(c,[]);return n}getTopologicalOrder(n){const s=new Map,o=new Map;for(const d of n)s.set(d,0),o.set(d,[]);for(const d of n){const h=this.dependencies.get(d)||new Set;for(const S of h)n.includes(S)&&(o.get(S).push(d),s.set(d,(s.get(d)||0)+1))}const r=[],c=[];for(const[d,h]of s)h===0&&r.push(d);for(;r.length>0;){const d=r.shift();c.push(d);for(const h of o.get(d)||[]){const S=s.get(h)-1;s.set(h,S),S===0&&r.push(h)}}return c.length===n.length?c:[]}clear(){this.dependencies.clear(),this.optionalDependencies.clear(),this.conflicts.clear()}getAllDependencies(n,s=new Set){if(s.has(n))return[];s.add(n);const o=Array.from(this.dependencies.get(n)||[]),r=[...o];for(const c of o)r.push(...this.getAllDependencies(c,s));return Array.from(new Set(r))}}function oe($,n){const s=$.split(".").map(Number),o=n.split(".").map(Number),r=Math.max(s.length,o.length);for(let c=0;c<r;c++){const d=s[c]||0,h=o[c]||0;if(d>h)return 1;if(d<h)return-1}return 0}function se($,n,s){return!(n&&oe($,n)<0||s&&oe($,s)>0)}function Se($){const n=new Map,s=new $e,o=new Map;let r={conflictStrategy:"warn",enableDebug:!1,...$};const c=t=>{if(t.minCoreVersion||t.maxCoreVersion){if(!se(W,t.minCoreVersion,t.maxCoreVersion)){const C=[t.minCoreVersion&&`>=${t.minCoreVersion}`,t.maxCoreVersion&&`<=${t.maxCoreVersion}`].filter(Boolean).join(", ");throw new Error(`[PluginManager] Plugin ${t.name}@${t.version||"0.0.0"} requires core version ${C}, but current core version is ${W}`)}r.enableDebug&&console.debug(`[PluginManager] Version check passed for ${t.name}: core ${W} is compatible`)}const l=new Set(n.keys()),E=s.checkDependencies(t.name,l);if(!E.satisfied){const y=E.missing.join(", ");throw new Error(`[PluginManager] Cannot register ${t.name}: missing required dependencies: ${y}`)}E.optional.length>0&&r.enableDebug&&console.warn(`[PluginManager] ${t.name}: missing optional dependencies: ${E.optional.join(", ")}`);const v=s.checkConflicts(t.name,l);if(v.hasConflict){const y=v.conflicts.join(", ");throw new Error(`[PluginManager] Cannot register ${t.name}: conflicts with: ${y}`)}s.addPlugin(t.name,t.dependencies,t.optionalDependencies,t.conflicts);const P=s.detectCycles();if(P.length>0){s.removePlugin(t.name);const y=P.map(C=>C.join(" -> ")).join("; ");throw new Error(`[PluginManager] Circular dependency detected: ${y}`)}if(n.has(t.name)){const y=n.get(t.name);if(y.version===t.version&&JSON.stringify(y.config)===JSON.stringify(t.config))return r.enableDebug&&console.warn(`[PluginManager] Plugin ${t.name}@${t.version} already registered, skipping`),!1;const C=r.conflictStrategy||"warn",e=`[PluginManager] Plugin ${t.name} conflict: ${y.version||"unknown"} -> ${t.version||"unknown"}`;switch(C){case"error":throw new Error(`${e}. Conflict strategy is 'error', registration blocked.`);case"warn":console.warn(`${e}, replacing`),d(t.name);break;case"ignore":return r.enableDebug&&console.debug(`${e}, ignoring new plugin (keeping existing)`),!1;case"override":r.enableDebug&&console.debug(`${e}, silently replacing`),d(t.name);break;default:console.warn(`${e}, unknown strategy, using default (warn)`),d(t.name)}}return n.set(t.name,t),t.init&&Promise.resolve(t.init()).catch(y=>{console.warn(`[PluginManager] init failed for ${t.name}`,y)}),r.enableDebug&&console.debug(`[PluginManager] Registered: ${t.name}@${t.version||"0.0.0"}`),!0},d=t=>{const l=n.get(t);return l?(s.removePlugin(t),l.destroy&&Promise.resolve(l.destroy()).catch(E=>{console.warn(`[PluginManager] destroy failed for ${l.name}`,E)}),n.delete(t),r.enableDebug&&console.debug(`[PluginManager] Unregistered: ${t}`),!0):!1},h=t=>n.get(t),S=()=>Array.from(n.values()).sort((t,l)=>{const E=t.priority??100,v=l.priority??100;return E-v}),x=new Set(["onLoadStart","onLoadSuccess","onLoadError","onEnterViewport","onLeaveViewport","onMount","onUnmount","onProgress","onSrcChange","onNetworkChange","onResize"]);return{register:c,unregister:d,getPlugin:h,getAllPlugins:S,executeHook:async(t,l,...E)=>{const v=S(),P=String(t);if(x.has(P)){const C=(await Promise.allSettled(v.map(async e=>{const a=e.hooks[t];if(a)try{return await Promise.resolve(a(l,...E))}catch(k){console.warn(`[PluginManager] hook ${P} failed in ${e.name}`,k);return}}))).filter(e=>e.status==="fulfilled").map(e=>e.value).filter(e=>e!==void 0&&e!==!0);return C.length>0?C:void 0}else{for(const y of v){const C=y.hooks[t];if(C)try{const e=await Promise.resolve(C(l,...E));if(e===!1)return!1;if(e!==void 0&&e!==!0)return e}catch(e){console.warn(`[PluginManager] hook ${P} failed in ${y.name}`,e)}}return}},getConfig:()=>({...r}),setConfig:t=>{r={...r,...t},r.enableDebug&&console.debug("[PluginManager] Config updated:",r)},savePluginState:(t,l)=>{const E=n.get(t);if(!E){console.warn(`[PluginManager] Cannot save state: plugin ${t} not found`);return}o.set(t,{data:l,version:E.version,timestamp:Date.now()}),r.enableDebug&&console.debug(`[PluginManager] State saved for ${t}`)},getPluginState:t=>o.get(t),hotReload:(t,l,E={})=>{const{preserveState:v=!0,migrateState:P,force:y=!1}=E;r.enableDebug&&console.debug(`[PluginManager] Hot reloading ${t} → ${l.name}@${l.version||"0.0.0"}`);const C=n.get(t);if(!C)throw new Error(`[PluginManager] Cannot hot reload: plugin ${t} not found`);let e;if(v&&(e=o.get(t),r.enableDebug&&e&&console.debug(`[PluginManager] Preserved state from ${t} (version: ${e.version})`)),(!y&&l.minCoreVersion||l.maxCoreVersion)&&!se(W,l.minCoreVersion,l.maxCoreVersion)){const k=[l.minCoreVersion&&`>=${l.minCoreVersion}`,l.maxCoreVersion&&`<=${l.maxCoreVersion}`].filter(Boolean).join(", ");throw new Error(`[PluginManager] Hot reload failed: ${l.name}@${l.version||"0.0.0"} requires core version ${k}, but current core version is ${W}. Use force: true to override.`)}d(t);try{c(l)}catch(a){throw console.error("[PluginManager] Hot reload failed, rolling back:",a),c(C),a}if(v&&e){let a=e.data;if(P&&e.version!==l.version&&e.version&&l.version)try{a=P(e.data,e.version,l.version),r.enableDebug&&console.debug(`[PluginManager] State migrated from ${e.version} → ${l.version}`)}catch(k){console.error(`[PluginManager] State migration failed for ${l.name}:`,k)}o.set(l.name,{data:a,version:l.version,timestamp:Date.now()}),r.enableDebug&&console.debug(`[PluginManager] State restored for ${l.name}`)}r.enableDebug&&console.debug(`[PluginManager] Hot reload successful: ${l.name}`)}}}class ce extends m.Component{constructor(n){super(n),this.state={hasError:!1,error:null}}static getDerivedStateFromError(n){return{hasError:!0,error:n}}componentDidCatch(n,s){var o,r;console.error(`[PluginErrorBoundary] Plugin "${this.props.pluginName}" encountered an error:`,n,s),(r=(o=this.props).onError)==null||r.call(o,n,s)}render(){return this.state.hasError?null:this.props.children}}function Y($){const n=$.config?JSON.stringify($.config,(s,o)=>typeof o=="function"?"[Function]":o!=null&&o.$$typeof?"[ReactElement]":o instanceof HTMLElement?"[HTMLElement]":typeof o=="object"&&o!==null&&(o._context||o.Provider)?"[ReactContext]":o):"";return`${$.name}@${$.version||"0.0.0"}#${n}`}function Me($,n){const s=Array.isArray(n)?{plugins:n,enableDebug:!1}:n,{plugins:o,enableDebug:r=!1,pluginManagerConfig:c}=s,d=m.forwardRef((h,S)=>{const{src:x}=h,M=m.useRef(Se({conflictStrategy:(c==null?void 0:c.conflictStrategy)||"warn",enableDebug:(c==null?void 0:c.enableDebug)??r})).current,I=m.useRef(ye()).current,H=m.useRef(new Map);m.useEffect(()=>{const u=new Set(o.map(Y)),g=new Set(H.current.keys()),w=o.filter(i=>{const D=Y(i);return!g.has(D)}),b=[];return H.current.forEach((i,D)=>{u.has(D)||b.push(i.name)}),w.forEach(i=>{if(i.hookFactory){const D=i.hookFactory.create(i.config||{});i.hookFactory.inject(i,D),r&&I.setData(`hook:${i.name}`,D)}M.register(i),H.current.set(Y(i),i),r&&console.debug(`[withPlugins] Registered plugin: ${i.name}@${i.version||"0.0.0"}`)}),b.forEach(i=>{M.unregister(i),H.current.forEach((D,V)=>{D.name===i&&H.current.delete(V)}),r&&console.debug(`[withPlugins] Unregistered plugin: ${i}`)}),()=>{H.current.forEach(i=>{M.unregister(i.name)}),H.current.clear()}},[o,M,I,r]),m.useEffect(()=>{if(r)try{const u=o.map(g=>g.name);console.debug("[withPlugins] active plugins:",u)}catch{}},[r,o]);const j=m.useRef(null),t=m.useRef(null),l=m.useRef(new Map),[E,v]=N.useState({isIdle:!0,isLoading:!1,isLoaded:!1,isError:!1}),[P,y]=N.useState(!1),[C,e]=N.useState(()=>ne()),[a,k]=N.useState(()=>re()),p=m.useMemo(()=>({src:x,containerRef:j,imageRef:t,bus:I,sharedData:l.current}),[x,I]),f=m.useMemo(()=>({networkInfo:C,deviceInfo:a}),[C,a]),R=m.useMemo(()=>({imageState:E,isIntersecting:P}),[E,P]),A=m.useRef({loadStartTime:0,loadEndTime:void 0,duration:void 0}),L=()=>({...p,...f,...R,props:h,performanceData:A.current}),B=m.useMemo(()=>L(),[p,f,R,h]),Z=m.useMemo(()=>{let u={...h};return o.forEach(g=>{g&&g.hooks&&g.hooks.transformProps&&(u=g.hooks.transformProps(u))}),u},[h,o]),X=u=>{try{return JSON.stringify(u,(g,w)=>w instanceof HTMLElement?"[HTMLElement]":w&&typeof w=="object"&&"current"in w?"[Ref]":typeof w=="function"?"[Function]":w instanceof Map?"[Map]":w instanceof Set?"[Set]":w)}catch{return u.map((w,b)=>`${b}:${typeof w}`).join(",")}},_=m.useRef(new Map),G=m.useRef(new Map),J=m.useRef(new Map),ae=m.useMemo(()=>{const u=new Map;return o.filter(g=>g&&g.hooks).map((g,w)=>{var z,te;const b=`${g.name}-${w}`,i=g.renderDeps?g.renderDeps(B):[p,f,R],D=X(i);if(u.set(b,D),!(_.current.get(b)!==D)&&G.current.has(b))return G.current.get(b);const F=(te=(z=g.hooks).render)==null?void 0:te.call(z,B);if(!F)return G.current.delete(b),null;const O=T.jsx(ce,{pluginName:g.name,children:F},b);return G.current.set(b,O),O}).filter(Boolean)},[o,B,p,f,R]),ie=m.useMemo(()=>o.filter(u=>u&&u.hooks).map((u,g)=>{var O,z;const w=`${u.name}-overlay-${g}`,b=u.renderDeps?u.renderDeps(B):[p,f,R],i=X(b);if(!(_.current.get(w)!==i)&&J.current.has(w))return J.current.get(w);const Q=(z=(O=u.hooks).renderOverlay)==null?void 0:z.call(O,B);if(!Q)return J.current.delete(w),_.current.set(w,i),null;const F=T.jsx(ce,{pluginName:u.name,children:Q},w);return J.current.set(w,F),_.current.set(w,i),F}).filter(Boolean),[o,B,p,f,R]);m.useEffect(()=>{const u=[],g=L();o.filter(b=>b&&b.hooks).forEach(b=>{var D,V;const i=(V=(D=b.hooks).onMount)==null?void 0:V.call(D,g);i&&u.push(i)});const w=I.on("progress",b=>{const i=L();M.executeHook("onProgress",i,b).catch(()=>{})});return()=>{const b=L();o.filter(i=>i&&i.hooks).forEach(i=>{var D,V;return(V=(D=i.hooks).onUnmount)==null?void 0:V.call(D,b)}),o.filter(i=>i).forEach(i=>M.unregister(i.name)),u.forEach(i=>typeof i=="function"&&i()),w&&w()}},[]);const ee=m.useRef(x);m.useEffect(()=>{const u=ee.current;if(u!==x){const g=L();M.executeHook("onSrcChange",g,u,x).catch(()=>{}),ee.current=x}},[x]),m.useEffect(()=>be(()=>{const g=ne(),w=re();e(g),k(w);const b=L();M.executeHook("onNetworkChange",b,g).catch(()=>{}),M.executeHook("onResize",b,w).catch(()=>{})}),[]);const fe=m.useCallback(async()=>{const u=L();return await M.executeHook("onLoad",u)},[]),le=m.useCallback(()=>{v({isIdle:!1,isLoading:!0,isLoaded:!1,isError:!1}),A.current.loadStartTime=performance.now();const u=L();M.executeHook("onBeforeLoad",u).catch(()=>{})},[]),ue=m.useCallback(u=>{v({isIdle:!1,isLoading:!1,isLoaded:!0,isError:!1}),A.current.loadEndTime=performance.now(),A.current.duration=A.current.loadEndTime-A.current.loadStartTime;const g=L();M.executeHook("onLoadSuccess",g,u).catch(()=>{})},[]),de=m.useCallback(u=>{v({isIdle:!1,isLoading:!1,isLoaded:!1,isError:!0});const g=L();M.executeHook("onLoadError",g,u).catch(()=>{})},[]),ge=m.useCallback(()=>{y(!0);const u=L();M.executeHook("onEnterViewport",u).catch(()=>{})},[]),he=m.useCallback(()=>{y(!1);const u=L();M.executeHook("onLeaveViewport",u).catch(()=>{})},[]),me={...Z,containerRefExternal:j,imageRefExternal:t,children:T.jsxs(T.Fragment,{children:[Z.children,ae,ie]}),onBeforeLoad:fe,onLoadStart:le,onLoadSuccess:ue,onLoadError:de,onEnterViewport:ge,onLeaveViewport:he};return T.jsx($,{ref:S,...me})});return d.displayName="WithPlugins(LazyLoadImageCore)",d}const W="1.0.0";export{$e as D,Se as c,Me as w};
