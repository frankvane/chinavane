var pe=Object.defineProperty;var we=(S,n,s)=>n in S?pe(S,n,{enumerable:!0,configurable:!0,writable:!0,value:s}):S[n]=s;var K=(S,n,s)=>we(S,typeof n!="symbol"?n+"":n,s);import{r as m,R as N,j as T}from"./index-B9PC2ohi.js";import{g as ne,a as re,c as be}from"./GlobalContext-DYUf_pwM.js";function ye(S={}){const{debug:n=!1,warnUncleared:s=!1,batchEvents:c}=S,r=new Map,o=new Map,d=new Map,h=n?new WeakMap:null,$=new Map;let D=null;const U=c||new Set(["progress","scroll","resize"]),M=(e,a)=>new RegExp("^"+e.replace(/\*/g,".*").replace(/\?/g,".")+"$").test(a),q=(e,a)=>{const k=r.get(e);if(k)for(const p of k)try{p(a)}catch(f){console.warn(`[PluginBus] handler error for event "${e}"`,f)}for(const[p,f]of o.entries())if(M(p,e))for(const R of f)try{R(a)}catch(A){console.warn(`[PluginBus] wildcard handler error for pattern "${p}"`,A)}},I=()=>{$.forEach((e,a)=>{const k=e[e.length-1];q(a,k)}),$.clear(),D=null},H=(e,a)=>{U.has(e)?($.has(e)||$.set(e,[]),$.get(e).push(a),D||(D=requestAnimationFrame(I))):q(e,a)},j=(e,a)=>{var p;if(h&&n)try{const f=new Error().stack,R=((p=f==null?void 0:f.split(`
`)[3])==null?void 0:p.trim().replace(/^at\s+/,""))||"unknown";h.set(a,R)}catch{}if(e.includes("*")||e.includes("?")){let f=o.get(e);return f||(f=new Set,o.set(e,f)),f.add(a),()=>{f==null||f.delete(a),(f==null?void 0:f.size)===0&&o.delete(e)}}else{let f=r.get(e);return f||(f=new Set,r.set(e,f)),f.add(a),()=>{f==null||f.delete(a),(f==null?void 0:f.size)===0&&r.delete(e)}}},t=(e,a)=>{const p=j(e,f=>{try{a(f)}finally{p()}});return p},l=(e,a)=>{if(!a)r.delete(e),o.delete(e);else{const k=r.get(e);k&&(k.delete(a),k.size===0&&r.delete(e));const p=o.get(e);p&&(p.delete(a),p.size===0&&o.delete(e))}},E=e=>{e?(r.delete(e),o.delete(e),$.delete(e)):(r.clear(),o.clear(),$.clear(),D&&(cancelAnimationFrame(D),D=null))},x=e=>d.get(e),P=(e,a)=>d.set(e,a),y=()=>{const e=[];return r.forEach((a,k)=>{const p=[];h&&n&&a.forEach(f=>{const R=h.get(f);R&&p.push(R)}),e.push({event:k,count:a.size,isWildcard:!1,sources:p.length>0?p:void 0})}),o.forEach((a,k)=>{const p=[];h&&n&&a.forEach(f=>{const R=h.get(f);R&&p.push(R)}),e.push({event:k,count:a.size,isWildcard:!0,sources:p.length>0?p:void 0})}),e},C=()=>({debug:n,warnUncleared:s,batchEvents:U});if(s&&typeof window<"u"){const e=()=>{const a=y();a.length>0&&console.warn(`[PluginBus] ${a.length} event listener(s) not cleared:`,a)};typeof window.addEventListener=="function"&&window.addEventListener("beforeunload",e)}return{emit:H,on:j,once:t,off:l,clear:E,getData:x,setData:P,getActiveListeners:y,getConfig:C}}class Se{constructor(){K(this,"dependencies");K(this,"optionalDependencies");K(this,"conflicts");this.dependencies=new Map,this.optionalDependencies=new Map,this.conflicts=new Map}addPlugin(n,s,c,r){s&&s.length>0&&this.dependencies.set(n,new Set(s)),c&&c.length>0&&this.optionalDependencies.set(n,new Set(c)),r&&r.length>0&&this.conflicts.set(n,new Set(r))}removePlugin(n){this.dependencies.delete(n),this.optionalDependencies.delete(n),this.conflicts.delete(n)}checkDependencies(n,s){const c=this.dependencies.get(n)||new Set,r=this.optionalDependencies.get(n)||new Set,o=Array.from(c).filter(h=>!s.has(h)),d=Array.from(r).filter(h=>!s.has(h));return{satisfied:o.length===0,missing:o,optional:d}}checkConflicts(n,s){const c=this.conflicts.get(n)||new Set,r=Array.from(c).filter(o=>s.has(o));return{hasConflict:r.length>0,conflicts:r}}detectCycles(){const n=[],s=new Set,c=new Set,r=(o,d)=>{if(c.has(o)){const $=d.indexOf(o);$!==-1&&n.push(d.slice($).concat(o));return}if(s.has(o))return;s.add(o),c.add(o),d.push(o);const h=this.dependencies.get(o)||new Set;for(const $ of h)r($,[...d]);c.delete(o)};for(const o of this.dependencies.keys())s.has(o)||r(o,[]);return n}getTopologicalOrder(n){const s=new Map,c=new Map;for(const d of n)s.set(d,0),c.set(d,[]);for(const d of n){const h=this.dependencies.get(d)||new Set;for(const $ of h)n.includes($)&&(c.get($).push(d),s.set(d,(s.get(d)||0)+1))}const r=[],o=[];for(const[d,h]of s)h===0&&r.push(d);for(;r.length>0;){const d=r.shift();o.push(d);for(const h of c.get(d)||[]){const $=s.get(h)-1;s.set(h,$),$===0&&r.push(h)}}return o.length===n.length?o:[]}clear(){this.dependencies.clear(),this.optionalDependencies.clear(),this.conflicts.clear()}getAllDependencies(n,s=new Set){if(s.has(n))return[];s.add(n);const c=Array.from(this.dependencies.get(n)||[]),r=[...c];for(const o of c)r.push(...this.getAllDependencies(o,s));return Array.from(new Set(r))}}function oe(S,n){const s=S.split(".").map(Number),c=n.split(".").map(Number),r=Math.max(s.length,c.length);for(let o=0;o<r;o++){const d=s[o]||0,h=c[o]||0;if(d>h)return 1;if(d<h)return-1}return 0}function se(S,n,s){return!(n&&oe(S,n)<0||s&&oe(S,s)>0)}function $e(S){const n=new Map,s=new Se,c=new Map;let r={conflictStrategy:"warn",enableDebug:!1,...S};const o=t=>{if(t.minCoreVersion||t.maxCoreVersion){if(!se(W,t.minCoreVersion,t.maxCoreVersion)){const C=[t.minCoreVersion&&`>=${t.minCoreVersion}`,t.maxCoreVersion&&`<=${t.maxCoreVersion}`].filter(Boolean).join(", ");throw new Error(`[PluginManager] Plugin ${t.name}@${t.version||"0.0.0"} requires core version ${C}, but current core version is ${W}`)}r.enableDebug&&console.debug(`[PluginManager] Version check passed for ${t.name}: core ${W} is compatible`)}const l=new Set(n.keys()),E=s.checkDependencies(t.name,l);if(!E.satisfied){const y=E.missing.join(", ");throw new Error(`[PluginManager] Cannot register ${t.name}: missing required dependencies: ${y}`)}E.optional.length>0&&r.enableDebug&&console.warn(`[PluginManager] ${t.name}: missing optional dependencies: ${E.optional.join(", ")}`);const x=s.checkConflicts(t.name,l);if(x.hasConflict){const y=x.conflicts.join(", ");throw new Error(`[PluginManager] Cannot register ${t.name}: conflicts with: ${y}`)}s.addPlugin(t.name,t.dependencies,t.optionalDependencies,t.conflicts);const P=s.detectCycles();if(P.length>0){s.removePlugin(t.name);const y=P.map(C=>C.join(" -> ")).join("; ");throw new Error(`[PluginManager] Circular dependency detected: ${y}`)}if(n.has(t.name)){const y=n.get(t.name);if(y.version===t.version&&JSON.stringify(y.config)===JSON.stringify(t.config))return r.enableDebug&&console.warn(`[PluginManager] Plugin ${t.name}@${t.version} already registered, skipping`),!1;const C=r.conflictStrategy||"warn",e=`[PluginManager] Plugin ${t.name} conflict: ${y.version||"unknown"} -> ${t.version||"unknown"}`;switch(C){case"error":throw new Error(`${e}. Conflict strategy is 'error', registration blocked.`);case"warn":console.warn(`${e}, replacing`),d(t.name);break;case"ignore":return r.enableDebug&&console.debug(`${e}, ignoring new plugin (keeping existing)`),!1;case"override":r.enableDebug&&console.debug(`${e}, silently replacing`),d(t.name);break;default:console.warn(`${e}, unknown strategy, using default (warn)`),d(t.name)}}return n.set(t.name,t),t.init&&Promise.resolve(t.init()).catch(y=>{console.warn(`[PluginManager] init failed for ${t.name}`,y)}),r.enableDebug&&console.debug(`[PluginManager] Registered: ${t.name}@${t.version||"0.0.0"}`),!0},d=t=>{const l=n.get(t);return l?(s.removePlugin(t),l.destroy&&Promise.resolve(l.destroy()).catch(E=>{console.warn(`[PluginManager] destroy failed for ${l.name}`,E)}),n.delete(t),r.enableDebug&&console.debug(`[PluginManager] Unregistered: ${t}`),!0):!1},h=t=>n.get(t),$=()=>Array.from(n.values()).sort((t,l)=>{const E=t.priority??100,x=l.priority??100;return E-x}),D=new Set(["onLoadStart","onLoadSuccess","onLoadError","onEnterViewport","onLeaveViewport","onMount","onUnmount","onProgress","onSrcChange","onNetworkChange","onResize"]);return{register:o,unregister:d,getPlugin:h,getAllPlugins:$,executeHook:async(t,l,...E)=>{const x=$(),P=String(t);if(D.has(P)){const C=(await Promise.allSettled(x.map(async e=>{const a=e.hooks[t];if(a)try{return await Promise.resolve(a(l,...E))}catch(k){console.warn(`[PluginManager] hook ${P} failed in ${e.name}`,k);return}}))).filter(e=>e.status==="fulfilled").map(e=>e.value).filter(e=>e!==void 0&&e!==!0);return C.length>0?C:void 0}else{for(const y of x){const C=y.hooks[t];if(C)try{const e=await Promise.resolve(C(l,...E));if(e===!1)return!1;if(e!==void 0&&e!==!0)return e}catch(e){console.warn(`[PluginManager] hook ${P} failed in ${y.name}`,e)}}return}},getConfig:()=>({...r}),setConfig:t=>{r={...r,...t},r.enableDebug&&console.debug("[PluginManager] Config updated:",r)},savePluginState:(t,l)=>{const E=n.get(t);if(!E){console.warn(`[PluginManager] Cannot save state: plugin ${t} not found`);return}c.set(t,{data:l,version:E.version,timestamp:Date.now()}),r.enableDebug&&console.debug(`[PluginManager] State saved for ${t}`)},getPluginState:t=>c.get(t),hotReload:(t,l,E={})=>{const{preserveState:x=!0,migrateState:P,force:y=!1}=E;r.enableDebug&&console.debug(`[PluginManager] Hot reloading ${t} → ${l.name}@${l.version||"0.0.0"}`);const C=n.get(t);if(!C)throw new Error(`[PluginManager] Cannot hot reload: plugin ${t} not found`);let e;if(x&&(e=c.get(t),r.enableDebug&&e&&console.debug(`[PluginManager] Preserved state from ${t} (version: ${e.version})`)),(!y&&l.minCoreVersion||l.maxCoreVersion)&&!se(W,l.minCoreVersion,l.maxCoreVersion)){const k=[l.minCoreVersion&&`>=${l.minCoreVersion}`,l.maxCoreVersion&&`<=${l.maxCoreVersion}`].filter(Boolean).join(", ");throw new Error(`[PluginManager] Hot reload failed: ${l.name}@${l.version||"0.0.0"} requires core version ${k}, but current core version is ${W}. Use force: true to override.`)}d(t);try{o(l)}catch(a){throw console.error("[PluginManager] Hot reload failed, rolling back:",a),o(C),a}if(x&&e){let a=e.data;if(P&&e.version!==l.version&&e.version&&l.version)try{a=P(e.data,e.version,l.version),r.enableDebug&&console.debug(`[PluginManager] State migrated from ${e.version} → ${l.version}`)}catch(k){console.error(`[PluginManager] State migration failed for ${l.name}:`,k)}c.set(l.name,{data:a,version:l.version,timestamp:Date.now()}),r.enableDebug&&console.debug(`[PluginManager] State restored for ${l.name}`)}r.enableDebug&&console.debug(`[PluginManager] Hot reload successful: ${l.name}`)}}}class ce extends m.Component{constructor(n){super(n),this.state={hasError:!1,error:null}}static getDerivedStateFromError(n){return{hasError:!0,error:n}}componentDidCatch(n,s){var c,r;console.error(`[PluginErrorBoundary] Plugin "${this.props.pluginName}" encountered an error:`,n,s),(r=(c=this.props).onError)==null||r.call(c,n,s)}render(){return this.state.hasError?null:this.props.children}}function Y(S){const n=S.config?JSON.stringify(S.config):"";return`${S.name}@${S.version||"0.0.0"}#${n}`}function Me(S,n){const s=Array.isArray(n)?{plugins:n,enableDebug:!1}:n,{plugins:c,enableDebug:r=!1,pluginManagerConfig:o}=s,d=m.forwardRef((h,$)=>{const{src:D}=h,M=m.useRef($e({conflictStrategy:(o==null?void 0:o.conflictStrategy)||"warn",enableDebug:(o==null?void 0:o.enableDebug)??r})).current,I=m.useRef(ye()).current,H=m.useRef(new Map);m.useEffect(()=>{const u=new Set(c.map(Y)),g=new Set(H.current.keys()),w=c.filter(i=>{const v=Y(i);return!g.has(v)}),b=[];return H.current.forEach((i,v)=>{u.has(v)||b.push(i.name)}),w.forEach(i=>{if(i.hookFactory){const v=i.hookFactory.create(i.config||{});i.hookFactory.inject(i,v),r&&I.setData(`hook:${i.name}`,v)}M.register(i),H.current.set(Y(i),i),r&&console.debug(`[withPlugins] Registered plugin: ${i.name}@${i.version||"0.0.0"}`)}),b.forEach(i=>{M.unregister(i),H.current.forEach((v,V)=>{v.name===i&&H.current.delete(V)}),r&&console.debug(`[withPlugins] Unregistered plugin: ${i}`)}),()=>{H.current.forEach(i=>{M.unregister(i.name)}),H.current.clear()}},[c,M,I,r]),m.useEffect(()=>{if(r)try{const u=c.map(g=>g.name);console.debug("[withPlugins] active plugins:",u)}catch{}},[r,c]);const j=m.useRef(null),t=m.useRef(null),l=m.useRef(new Map),[E,x]=N.useState({isIdle:!0,isLoading:!1,isLoaded:!1,isError:!1}),[P,y]=N.useState(!1),[C,e]=N.useState(()=>ne()),[a,k]=N.useState(()=>re()),p=m.useMemo(()=>({src:D,containerRef:j,imageRef:t,bus:I,sharedData:l.current}),[D,I]),f=m.useMemo(()=>({networkInfo:C,deviceInfo:a}),[C,a]),R=m.useMemo(()=>({imageState:E,isIntersecting:P}),[E,P]),A=m.useRef({loadStartTime:0,loadEndTime:void 0,duration:void 0}),L=()=>({...p,...f,...R,props:h,performanceData:A.current}),B=m.useMemo(()=>L(),[p,f,R,h]),Z=m.useMemo(()=>{let u={...h};return c.forEach(g=>{g&&g.hooks&&g.hooks.transformProps&&(u=g.hooks.transformProps(u))}),u},[h,c]),X=u=>{try{return JSON.stringify(u,(g,w)=>w instanceof HTMLElement?"[HTMLElement]":w&&typeof w=="object"&&"current"in w?"[Ref]":typeof w=="function"?"[Function]":w instanceof Map?"[Map]":w instanceof Set?"[Set]":w)}catch{return u.map((w,b)=>`${b}:${typeof w}`).join(",")}},G=m.useRef(new Map),J=m.useRef(new Map),_=m.useRef(new Map),ae=m.useMemo(()=>{const u=new Map;return c.filter(g=>g&&g.hooks).map((g,w)=>{var z,te;const b=`${g.name}-${w}`,i=g.renderDeps?g.renderDeps(B):[p,f,R],v=X(i);if(u.set(b,v),!(G.current.get(b)!==v)&&J.current.has(b))return J.current.get(b);const F=(te=(z=g.hooks).render)==null?void 0:te.call(z,B);if(!F)return J.current.delete(b),null;const O=T.jsx(ce,{pluginName:g.name,children:F},b);return J.current.set(b,O),O}).filter(Boolean)},[c,B,p,f,R]),ie=m.useMemo(()=>c.filter(u=>u&&u.hooks).map((u,g)=>{var O,z;const w=`${u.name}-overlay-${g}`,b=u.renderDeps?u.renderDeps(B):[p,f,R],i=X(b);if(!(G.current.get(w)!==i)&&_.current.has(w))return _.current.get(w);const Q=(z=(O=u.hooks).renderOverlay)==null?void 0:z.call(O,B);if(!Q)return _.current.delete(w),G.current.set(w,i),null;const F=T.jsx(ce,{pluginName:u.name,children:Q},w);return _.current.set(w,F),G.current.set(w,i),F}).filter(Boolean),[c,B,p,f,R]);m.useEffect(()=>{const u=[],g=L();c.filter(b=>b&&b.hooks).forEach(b=>{var v,V;const i=(V=(v=b.hooks).onMount)==null?void 0:V.call(v,g);i&&u.push(i)});const w=I.on("progress",b=>{const i=L();M.executeHook("onProgress",i,b).catch(()=>{})});return()=>{const b=L();c.filter(i=>i&&i.hooks).forEach(i=>{var v,V;return(V=(v=i.hooks).onUnmount)==null?void 0:V.call(v,b)}),c.filter(i=>i).forEach(i=>M.unregister(i.name)),u.forEach(i=>typeof i=="function"&&i()),w&&w()}},[]);const ee=m.useRef(D);m.useEffect(()=>{const u=ee.current;if(u!==D){const g=L();M.executeHook("onSrcChange",g,u,D).catch(()=>{}),ee.current=D}},[D]),m.useEffect(()=>be(()=>{const g=ne(),w=re();e(g),k(w);const b=L();M.executeHook("onNetworkChange",b,g).catch(()=>{}),M.executeHook("onResize",b,w).catch(()=>{})}),[]);const fe=m.useCallback(async()=>{const u=L();return await M.executeHook("onLoad",u)},[]),le=m.useCallback(()=>{x({isIdle:!1,isLoading:!0,isLoaded:!1,isError:!1}),A.current.loadStartTime=performance.now();const u=L();M.executeHook("onBeforeLoad",u).catch(()=>{})},[]),ue=m.useCallback(u=>{x({isIdle:!1,isLoading:!1,isLoaded:!0,isError:!1}),A.current.loadEndTime=performance.now(),A.current.duration=A.current.loadEndTime-A.current.loadStartTime;const g=L();M.executeHook("onLoadSuccess",g,u).catch(()=>{})},[]),de=m.useCallback(u=>{x({isIdle:!1,isLoading:!1,isLoaded:!1,isError:!0});const g=L();M.executeHook("onLoadError",g,u).catch(()=>{})},[]),ge=m.useCallback(()=>{y(!0);const u=L();M.executeHook("onEnterViewport",u).catch(()=>{})},[]),he=m.useCallback(()=>{y(!1);const u=L();M.executeHook("onLeaveViewport",u).catch(()=>{})},[]),me={...Z,containerRefExternal:j,imageRefExternal:t,children:T.jsxs(T.Fragment,{children:[Z.children,ae,ie]}),onBeforeLoad:fe,onLoadStart:le,onLoadSuccess:ue,onLoadError:de,onEnterViewport:ge,onLeaveViewport:he};return T.jsx(S,{ref:$,...me})});return d.displayName="WithPlugins(LazyLoadImageCore)",d}const W="1.0.0";export{Se as D,$e as c,Me as w};
