const o=new Map,s=[];function v(){return Date.now()}function C(t){if(!(t<=0))for(;s.length>t;){const r=s.shift();r&&o.has(r)&&o.delete(r)}}function M(t){const r=s.indexOf(t);r>=0&&s.splice(r,1),s.push(t)}function m(t,r){const n=o.get(t);if(n){if(r&&r>0&&v()-n.time>r){o.delete(t);const a=s.indexOf(t);a>=0&&s.splice(a,1);return}return M(t),n.value}}function w(t,r,n){o.set(t,{value:r,time:v()}),M(t),C(n)}const L={get:m,set:w,has:(t,r)=>m(t,r)!==void 0,clear:()=>{o.clear(),s.splice(0,s.length)},size:()=>o.size};function U(t={}){const{enabled:r=!0,maxEntries:n=200,ttlMs:a,debug:u=!1}=t,f=new Map,l=new Set,d=new Map,b=100;function g(e,c,h){const i=`${c}:${h.src}`,y=Date.now(),p=d.get(i)||0;y-p<b||(d.set(i,y),e==null||e.emit(c,h),setTimeout(()=>{d.delete(i)},1e3))}return{name:"cache-memory",version:"1.0.0",config:t,hooks:{onLoad:async e=>{if(r){if(l.has(e.src)){if(u)try{console.warn("[MemoryCache] Prevented reentry for",e.src)}catch{}return}l.add(e.src);try{const c=m(e.src,a);if(c){if(u)try{console.debug("[MemoryCache] hit",{src:e.src})}catch{}if(g(e.bus,"cache:hit",{level:"memory",src:e.src}),!c.startsWith("blob:"))return c}return}finally{l.delete(e.src)}}},onLoadSuccess:(e,c)=>{if(r&&(c.startsWith("blob:")||w(e.src,c,n),u))try{console.debug("[MemoryCache] set",{src:e.src,length:c.length})}catch{}},onSrcChange:(e,c,h)=>{if(!r)return;g(e.bus,"cache:src-change",{oldSrc:c,newSrc:h,src:c});const i=f.get(c);if(i){try{URL.revokeObjectURL(i)}catch{}f.delete(c)}},onUnmount:e=>{const c=f.get(e.src);if(c){try{URL.revokeObjectURL(c)}catch{}f.delete(e.src)}}}}}export{L as M,U as c};
