var j=Object.defineProperty;var z=(i,e,t)=>e in i?j(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var E=(i,e,t)=>z(i,typeof e!="symbol"?e+"":e,t);const R={TIMEOUT:3e4,MAX_RETRIES:3,RETRY_DELAY:1e3,RETRY_BACKOFF:2,CACHE_SIZE_INFLIGHT:50,CACHE_SIZE_CONTROLLERS:50,CACHE_SIZE_OBJECT_URLS:100},U={CLIENT_ERROR_MIN:400,CLIENT_ERROR_MAX:500,SERVER_ERROR_MIN:500,SERVER_ERROR_MAX:600,OK:200,NOT_FOUND:404,FORBIDDEN:403,UNAUTHORIZED:401,INTERNAL_SERVER_ERROR:500,SERVICE_UNAVAILABLE:503};class p{constructor(e,t){E(this,"cache");E(this,"maxSize");E(this,"onEvict");if(e<=0)throw new Error("LRUCache maxSize must be greater than 0");this.cache=new Map,this.maxSize=e,this.onEvict=t}get(e){const t=this.cache.get(e);return t!==void 0&&(this.cache.delete(e),this.cache.set(e,t)),t}set(e,t){if(this.cache.has(e)&&this.cache.delete(e),this.cache.set(e,t),this.cache.size>this.maxSize){const c=this.cache.keys().next().value;if(c!==void 0){const a=this.cache.get(c);if(this.cache.delete(c),this.onEvict&&a!==void 0)try{this.onEvict(c,a)}catch(y){console.warn("[LRUCache] onEvict callback error:",y)}}}}delete(e){const t=this.cache.get(e),c=this.cache.delete(e);if(c&&this.onEvict&&t!==void 0)try{this.onEvict(e,t)}catch(a){console.warn("[LRUCache] onEvict callback error:",a)}return c}has(e){return this.cache.has(e)}clear(){this.onEvict&&this.cache.forEach((e,t)=>{try{this.onEvict(t,e)}catch(c){console.warn("[LRUCache] onEvict callback error:",c)}}),this.cache.clear()}get size(){return this.cache.size}keys(){return this.cache.keys()}values(){return this.cache.values()}forEach(e){this.cache.forEach(e)}}class ${constructor(e=1e3,t=10){E(this,"samples",[]);E(this,"windowSize");E(this,"maxSamples");this.windowSize=e,this.maxSamples=t}addSample(e){const t=Date.now();this.samples.push({bytes:e,timestamp:t});const c=t-this.windowSize;this.samples=this.samples.filter(a=>a.timestamp>c),this.samples.length>this.maxSamples&&this.samples.shift()}getSpeed(){if(this.samples.length<2)return 0;const e=this.samples[0],t=this.samples[this.samples.length-1],c=t.bytes-e.bytes,a=(t.timestamp-e.timestamp)/1e3;return a<=0?0:c/a}estimateTimeRemaining(e,t){const c=this.getSpeed();return c<=0||t<=0?0:(t-e)/c}reset(){this.samples=[]}}const _=new p(R.CACHE_SIZE_INFLIGHT),m=new p(R.CACHE_SIZE_CONTROLLERS,(i,e)=>{try{e.abort()}catch{}}),b=new p(R.CACHE_SIZE_OBJECT_URLS,(i,e)=>{try{URL.revokeObjectURL(e)}catch{}});function B(i={}){const{enabled:e=!0,cacheKeyFn:t,timeout:c=R.TIMEOUT,maxRetries:a=R.MAX_RETRIES,retryDelay:y=R.RETRY_DELAY,retryBackoff:A=R.RETRY_BACKOFF}=i,S=o=>t?t(o.src):o.src,F=o=>{const s=S(o),r=m.get(s);if(r){try{r.abort()}catch{}m.delete(s)}},N=o=>{const s=S(o),r=b.get(s);if(r){try{URL.revokeObjectURL(r)}catch{}b.delete(s)}};async function g(o,s,r=0){try{const n=fetch(o,{signal:s}),l=new Promise((L,w)=>{setTimeout(()=>{w(new Error(`Fetch timeout after ${c}ms`))},c)}),h=await Promise.race([n,l]);if(!h.ok)throw h.status>=U.CLIENT_ERROR_MIN&&h.status<U.CLIENT_ERROR_MAX?new Error(`HTTP ${h.status}: ${h.statusText}`):new Error(`Server error: ${h.status}`);return h}catch(n){if(s.aborted||n.name==="AbortError"||r>=a||n.message&&(n.message.includes("404")||n.message.includes("403")||n.message.includes("401")))throw n;const l=y*Math.pow(A,r);if(console.debug(`[FetchLoader] Retrying (${r+1}/${a}) after ${l}ms for ${o}`),await new Promise(h=>setTimeout(h,l)),s.aborted)throw new Error("Request aborted during retry delay");return g(o,s,r+1)}}async function k(o){const s=o.src,r=t?t(s):s;if(_.has(r))return _.get(r);const n=(async()=>{var w;const l=new AbortController,{signal:h}=l;m.set(r,l);const L=new $;try{const d=await g(s,h);if(!d.body)return m.delete(r),s;const C=d.headers.get("content-length"),u=C?parseInt(C,10):0,v=d.body.getReader(),I=[];let f=0;try{for(;;){const{done:H,value:T}=await v.read();if(H)break;if(T){I.push(T),f+=T.length,L.addSample(f);const D={loaded:f,total:u,percent:u>0?Math.round(f/u*100):0,indeterminate:u===0,speed:L.getSpeed(),estimatedTime:L.estimateTimeRemaining(f,u),timestamp:Date.now()};(w=o.bus)==null||w.emit("progress",D)}}}finally{v.releaseLock()}const M=new Blob(I),O=URL.createObjectURL(M);return b.set(r,O),m.delete(r),O}catch(d){return m.delete(r),d.name==="AbortError"||h.aborted||console.warn(`[FetchLoader] Failed to load ${s}:`,d.message),s}finally{_.delete(r)}})();return _.set(r,n),n}return{name:"fetch-loader",version:"1.0.0",priority:10,config:i,hooks:{async onLoad(o){if(e)try{return await k(o)}catch(s){console.warn("[FetchLoader] onLoad error:",s);return}},onUnmount(o){F(o),N(o)}}}}export{B as c};
