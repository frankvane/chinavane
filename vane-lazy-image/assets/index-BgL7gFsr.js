let D=null;function B(l,t){return D||(D=new Promise((a,o)=>{const s=indexedDB.open(l,1);s.onupgradeneeded=()=>{const r=s.result;r.objectStoreNames.contains(t)||r.createObjectStore(t)},s.onsuccess=()=>a(s.result),s.onerror=()=>o(s.error)})),D}async function C(l,t){try{const a=await B(t.dbName,t.storeName),s=a.transaction(t.storeName,"readonly").objectStore(t.storeName),r=await new Promise((n,y)=>{const h=s.get(l);h.onsuccess=()=>n(h.result),h.onerror=()=>y(h.error)});if(!r)return;if(t.ttlMs>0&&Date.now()-r.time>t.ttlMs){try{a.transaction(t.storeName,"readwrite").objectStore(t.storeName).delete(l)}catch{}return}return r}catch(a){if(t.debug)try{console.warn("[IDBCache] get failed",a)}catch{}return}}async function w(l,t,a){try{const r=(await B(a.dbName,a.storeName)).transaction(a.storeName,"readwrite").objectStore(a.storeName),n=typeof t=="string"?{value:t,time:Date.now()}:{blob:t,time:Date.now(),mime:t.type};await new Promise((y,h)=>{const b=r.put(n,l);b.onsuccess=()=>y(),b.onerror=()=>h(b.error)})}catch(o){if(a.debug)try{console.warn("[IDBCache] set failed",o)}catch{}}}const I={get:C,set:w};function g(l){try{const t=l.split(","),a=t[0].match(/:(.*?);/),o=a?a[1]:"application/octet-stream",s=atob(t[1]);let r=s.length;const n=new Uint8Array(r);for(;r--;)n[r]=s.charCodeAt(r);return new Blob([n],{type:o})}catch{return null}}function p(l={}){const{enabled:t=!0,dbName:a="LLI-Cache",storeName:o="images",ttlMs:s=7*24*60*60*1e3,debug:r=!1}=l,n=new Map,y=new Set,h=new Set,b=new Set;return{name:"cache-idb",version:"1.0.0",config:l,hooks:{onLoad:async e=>{var c,u,d,i;if(t){if(y.has(e.src)){if(r)try{console.warn("[IDBCache] Prevented reentry for",e.src)}catch{}return}y.add(e.src);try{const m=await C(e.src,{dbName:a,storeName:o,ttlMs:s,debug:r});if(m){if(r)try{console.debug("[IDBCache] hit",{src:e.src})}catch{}if((c=e.bus)==null||c.emit("cache:hit",{level:"idb",src:e.src}),m.blob){let f=(u=e.sharedData)==null?void 0:u.get("fetch-loader:object-url");if(!f){f=URL.createObjectURL(m.blob),n.set(e.src,f);try{(d=e.sharedData)==null||d.set("fetch-loader:object-url",f),(i=e.sharedData)==null||i.set("fetch-loader:blob",m.blob)}catch{}}return f}return m.value}return}finally{y.delete(e.src)}}},onLoadSuccess:async(e,c)=>{var u;if(t){if(h.has(e.src)){if(r)try{console.warn("[IDBCache] Write already in progress for",e.src)}catch{}return}h.add(e.src);try{let d=(u=e.sharedData)==null?void 0:u.get("fetch-loader:blob");if(!d&&!b.has(e.src)){if(r)try{console.debug("[IDBCache] No blob in sharedData, fetching from source:",e.src)}catch{}b.add(e.src);try{const i=new AbortController,m=setTimeout(()=>i.abort(),5e3),f=await fetch(e.src,{cache:"force-cache",signal:i.signal});if(clearTimeout(m),f.ok&&(d=await f.blob(),r))try{console.debug("[IDBCache] ✅ Fetched blob from source:",{src:e.src,size:d.size,type:d.type})}catch{}}catch(i){if(r&&(i==null?void 0:i.name)!=="AbortError")try{console.warn("[IDBCache] ⚠️ Fetch from source failed:",i)}catch{}}finally{b.delete(e.src)}}else if(b.has(e.src)&&r)try{console.warn("[IDBCache] ⚠️ Fetch already in progress, skipping:",e.src)}catch{}if(d){if(await w(e.src,d,{dbName:a,storeName:o,debug:r}),r)try{console.debug("[IDBCache] ✅ Stored blob successfully:",{src:e.src,size:d.size,type:d.type})}catch{}}else if(c.startsWith("data:")){const i=g(c);if(i){if(await w(e.src,i,{dbName:a,storeName:o,debug:r}),r)try{console.debug("[IDBCache] ✅ Stored blob from dataURL")}catch{}}else if(await w(e.src,c,{dbName:a,storeName:o,debug:r}),r)try{console.warn("[IDBCache] ⚠️ Stored dataURL as string (not ideal)")}catch{}}else if(await w(e.src,c,{dbName:a,storeName:o,debug:r}),r)try{console.warn("[IDBCache] ⚠️ Stored URL only, no blob available:",{src:e.src,displaySrc:c})}catch{}}catch{}finally{h.delete(e.src)}if(r)try{console.debug("[IDBCache] set",{src:e.src})}catch{}}},onSrcChange:(e,c)=>{const u=n.get(c);if(u){try{URL.revokeObjectURL(u)}catch{}n.delete(c)}},onUnmount:e=>{const c=n.get(e.src);if(c){try{URL.revokeObjectURL(c)}catch{}n.delete(e.src)}}}}}export{I,p as c};
