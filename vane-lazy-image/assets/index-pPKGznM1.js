const u=(()=>{const c=new Map;function s(i,o){const t=c.get(i);if(t&&t.initialized)return t.idleMs=o>0?o:t.idleMs,t;const n={isIdle:!0,timer:null,idleWaiters:new Set,idleMs:o>0?o:120,initialized:!1,cleanup:void 0},e=()=>{n.isIdle=!1,n.timer&&clearTimeout(n.timer),n.timer=setTimeout(()=>{n.isIdle=!0,n.idleWaiters.forEach(r=>{try{r()}catch{}}),n.idleWaiters.clear()},n.idleMs)};if(i==="window")window.addEventListener("scroll",e,{passive:!0}),window.addEventListener("wheel",e,{passive:!0}),window.addEventListener("touchmove",e,{passive:!0}),n.cleanup=()=>{window.removeEventListener("scroll",e),window.removeEventListener("wheel",e),window.removeEventListener("touchmove",e)};else{try{i.addEventListener("scroll",e,{passive:!0}),i.addEventListener("wheel",e,{passive:!0}),i.addEventListener("touchmove",e,{passive:!0})}catch{}n.cleanup=()=>{try{i.removeEventListener("scroll",e),i.removeEventListener("wheel",e),i.removeEventListener("touchmove",e)}catch{}}}return n.initialized=!0,c.set(i,n),n}async function d(i,o,t){const n=s(i,o);n.isIdle||await new Promise(e=>{let r=null;const l=()=>{r&&clearTimeout(r),e()};n.idleWaiters.add(l),typeof t=="number"&&t>0&&(r=setTimeout(()=>{n.idleWaiters.delete(l),e()},t))})}return{ensure:s,waitForIdle:d}})();function v(c={}){const{idleMs:s=120,onlyWhenIntersecting:d=!0,maxWaitMs:i=1200,target:o="window",axis:t="vertical",debug:n=!1}=c;return{name:"scroll-idle",version:"1.0.0",config:c,hooks:{onMount:e=>{var a;const r=((a=e.containerRef)==null?void 0:a.current)||null,l=o==="container"&&r?r:"window";if(u.ensure(l,s),n)try{console.debug("[ScrollIdle] mount",{idleMs:s,target:o,axis:t,hasContainer:!!r})}catch{}},onLoad:async e=>{var r;if(e.props.loading!=="eager"&&(!d||e.isIntersecting)){const l=((r=e.containerRef)==null?void 0:r.current)||null,a=o==="container"&&l?l:"window";n&&console.debug(`[ScrollIdle] waiting for idle ${s}ms (max ${i}ms)`,{target:o,axis:t});try{await u.waitForIdle(a,s,i)}catch{}}}}}}export{v as c};
